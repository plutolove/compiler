
// Generated from ./src/parser/sql_parser.g4 by ANTLR 4.12.0


#include "sql_parserVisitor.h"

#include "sql_parserParser.h"


using namespace antlrcpp;
using namespace sql;

using namespace antlr4;

namespace {

struct Sql_parserParserStaticData final {
  Sql_parserParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  Sql_parserParserStaticData(const Sql_parserParserStaticData&) = delete;
  Sql_parserParserStaticData(Sql_parserParserStaticData&&) = delete;
  Sql_parserParserStaticData& operator=(const Sql_parserParserStaticData&) = delete;
  Sql_parserParserStaticData& operator=(Sql_parserParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag sql_parserParserOnceFlag;
Sql_parserParserStaticData *sql_parserParserStaticData = nullptr;

void sql_parserParserInitialize() {
  assert(sql_parserParserStaticData == nullptr);
  auto staticData = std::make_unique<Sql_parserParserStaticData>(
    std::vector<std::string>{
      "singleStatement", "singleDataType", "statement", "commentSpec", "query", 
      "queryOrganization", "queryTerm", "queryPrimary", "sortItem", "querySpecification", 
      "selectClause", "whereClause", "fromClause", "setQuantifier", "relation", 
      "identifierList", "identifierSeq", "orderedIdentifierList", "orderedIdentifier", 
      "identifierCommentList", "identifierComment", "relationPrimary", "tableAlias", 
      "multipartIdentifierList", "multipartIdentifier", "namedExpression", 
      "namedExpressionSeq", "expression", "booleanExpression", "predicate", 
      "valueExpression", "primaryExpression", "constant", "comparisonOperator", 
      "arithmeticOperator", "predicateOperator", "booleanValue", "interval", 
      "errorCapturingMultiUnitsInterval", "multiUnitsInterval", "errorCapturingUnitToUnitInterval", 
      "unitToUnitInterval", "intervalValue", "colPosition", "dataType", 
      "qualifiedColTypeWithPositionList", "qualifiedColTypeWithPosition", 
      "colTypeList", "colType", "complexColTypeList", "complexColType", 
      "whenClause", "windowClause", "namedWindow", "windowSpec", "windowFrame", 
      "frameBound", "qualifiedNameList", "functionName", "qualifiedName", 
      "errorCapturingIdentifier", "errorCapturingIdentifierExtra", "identifier", 
      "strictIdentifier", "quotedIdentifier", "number", "alterColumnAction", 
      "ansiNonReserved", "strictNonReserved", "nonReserved"
    },
    std::vector<std::string>{
      "", "';'", "','", "'('", "')'", "'.'", "'['", "']'", "':'", "'ADD'", 
      "'AFTER'", "'ALL'", "'ALTER'", "'ANALYZE'", "'AND'", "'ANTI'", "'ANY'", 
      "'ARCHIVE'", "'ARRAY'", "'AS'", "'ASC'", "'AT'", "'AUTHORIZATION'", 
      "'BETWEEN'", "'BOTH'", "'BUCKET'", "'BUCKETS'", "'BY'", "'CACHE'", 
      "'CASCADE'", "'CASE'", "'CAST'", "'CHANGE'", "'CHECK'", "'CLEAR'", 
      "'CLUSTER'", "'CLUSTERED'", "'CODEGEN'", "'COLLATE'", "'COLLECTION'", 
      "'COLUMN'", "'COLUMNS'", "'COMMENT'", "'COMMIT'", "'COMPACT'", "'COMPACTIONS'", 
      "'COMPUTE'", "'CONCATENATE'", "'CONSTRAINT'", "'COST'", "'CREATE'", 
      "'CROSS'", "'CUBE'", "'CURRENT'", "'CURRENT_DATE'", "'CURRENT_TIME'", 
      "'CURRENT_TIMESTAMP'", "'CURRENT_USER'", "'DATA'", "'DATABASE'", "", 
      "'DBPROPERTIES'", "'DEFINED'", "'DELETE'", "'DELIMITED'", "'DESC'", 
      "'DESCRIBE'", "'DFS'", "'DIRECTORIES'", "'DIRECTORY'", "'DISTINCT'", 
      "'DISTRIBUTE'", "'DIV'", "'DROP'", "'ELSE'", "'END'", "'ESCAPE'", 
      "'ESCAPED'", "'EXCEPT'", "'EXCHANGE'", "'EXISTS'", "'EXPLAIN'", "'EXPORT'", 
      "'EXTENDED'", "'EXTERNAL'", "'EXTRACT'", "'FALSE'", "'FETCH'", "'FIELDS'", 
      "'FILTER'", "'FILEFORMAT'", "'FIRST'", "'FOLLOWING'", "'FOR'", "'FOREIGN'", 
      "'FORMAT'", "'FORMATTED'", "'FROM'", "'FULL'", "'FUNCTION'", "'FUNCTIONS'", 
      "'GLOBAL'", "'GRANT'", "'GROUP'", "'GROUPING'", "'HAVING'", "'IF'", 
      "'IGNORE'", "'IMPORT'", "'IN'", "'INDEX'", "'INDEXES'", "'INNER'", 
      "'INPATH'", "'INPUTFORMAT'", "'INSERT'", "'INTERSECT'", "'INTERVAL'", 
      "'INTO'", "'IS'", "'ITEMS'", "'JOIN'", "'KEYS'", "'LAST'", "'LATERAL'", 
      "'LAZY'", "'LEADING'", "'LEFT'", "'LIKE'", "'LIMIT'", "'LINES'", "'LIST'", 
      "'LOAD'", "'LOCAL'", "'LOCATION'", "'LOCK'", "'LOCKS'", "'LOGICAL'", 
      "'MACRO'", "'MAP'", "'MATCHED'", "'MERGE'", "'MSCK'", "'NAMESPACE'", 
      "'NAMESPACES'", "'NATURAL'", "'NO'", "", "'NULL'", "'NULLS'", "'OF'", 
      "'ON'", "'ONLY'", "'OPTION'", "'OPTIONS'", "'OR'", "'ORDER'", "'OUT'", 
      "'OUTER'", "'OUTPUTFORMAT'", "'OVER'", "'OVERLAPS'", "'OVERLAY'", 
      "'OVERWRITE'", "'PARTITION'", "'PARTITIONED'", "'PARTITIONS'", "'PERCENT'", 
      "'PIVOT'", "'PLACING'", "'POSITION'", "'PRECEDING'", "'PRIMARY'", 
      "'PRINCIPALS'", "'PROPERTIES'", "'PURGE'", "'QUERY'", "'RANGE'", "'RECORDREADER'", 
      "'RECORDWRITER'", "'RECOVER'", "'REDUCE'", "'REFERENCES'", "'REFRESH'", 
      "'RENAME'", "'REPAIR'", "'REPLACE'", "'RESET'", "'RESTRICT'", "'REVOKE'", 
      "'RIGHT'", "", "'ROLE'", "'ROLES'", "'ROLLBACK'", "'ROLLUP'", "'ROW'", 
      "'ROWS'", "'SCHEMA'", "'SELECT'", "'SEMI'", "'SEPARATED'", "'SERDE'", 
      "'SERDEPROPERTIES'", "'SESSION_USER'", "'SET'", "'MINUS'", "'SETS'", 
      "'SHOW'", "'SKEWED'", "'SOME'", "'SORT'", "'SORTED'", "'START'", "'STATISTICS'", 
      "'STORED'", "'STRATIFY'", "'STRUCT'", "'SUBSTR'", "'SUBSTRING'", "'TABLE'", 
      "'TABLES'", "'TABLESAMPLE'", "'TBLPROPERTIES'", "", "'TERMINATED'", 
      "'THEN'", "'TO'", "'TOUCH'", "'TRAILING'", "'TRANSACTION'", "'TRANSACTIONS'", 
      "'TRANSFORM'", "'TRIM'", "'TRUE'", "'TRUNCATE'", "'TYPE'", "'UNARCHIVE'", 
      "'UNBOUNDED'", "'UNCACHE'", "'UNION'", "'UNIQUE'", "'UNKNOWN'", "'UNLOCK'", 
      "'UNSET'", "'UPDATE'", "'USE'", "'USER'", "'USING'", "'VALUES'", "'VIEW'", 
      "'VIEWS'", "'WHEN'", "'WHERE'", "'WINDOW'", "'WITH'", "", "'<=>'", 
      "'<>'", "'!='", "'<'", "", "'>'", "", "'+'", "'-'", "'*'", "'/'", 
      "'%'", "'~'", "'&'", "'|'", "'||'", "'^'", "", "", "", "", "", "", 
      "", "", "", "", "", "", "'/**/'"
    },
    std::vector<std::string>{
      "", "", "", "", "", "", "", "", "", "ADD", "AFTER", "ALL", "ALTER", 
      "ANALYZE", "AND", "ANTI", "ANY", "ARCHIVE", "ARRAY", "AS", "ASC", 
      "AT", "AUTHORIZATION", "BETWEEN", "BOTH", "BUCKET", "BUCKETS", "BY", 
      "CACHE", "CASCADE", "CASE", "CAST", "CHANGE", "CHECK", "CLEAR", "CLUSTER", 
      "CLUSTERED", "CODEGEN", "COLLATE", "COLLECTION", "COLUMN", "COLUMNS", 
      "COMMENT", "COMMIT", "COMPACT", "COMPACTIONS", "COMPUTE", "CONCATENATE", 
      "CONSTRAINT", "COST", "CREATE", "CROSS", "CUBE", "CURRENT", "CURRENT_DATE", 
      "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "DATA", "DATABASE", 
      "DATABASES", "DBPROPERTIES", "DEFINED", "DELETE", "DELIMITED", "DESC", 
      "DESCRIBE", "DFS", "DIRECTORIES", "DIRECTORY", "DISTINCT", "DISTRIBUTE", 
      "DIV", "DROP", "ELSE", "END", "ESCAPE", "ESCAPED", "EXCEPT", "EXCHANGE", 
      "EXISTS", "EXPLAIN", "EXPORT", "EXTENDED", "EXTERNAL", "EXTRACT", 
      "FALSE", "FETCH", "FIELDS", "FILTER", "FILEFORMAT", "FIRST", "FOLLOWING", 
      "FOR", "FOREIGN", "FORMAT", "FORMATTED", "FROM", "FULL", "FUNCTION", 
      "FUNCTIONS", "GLOBAL", "GRANT", "GROUP", "GROUPING", "HAVING", "IF", 
      "IGNORE", "IMPORT", "IN", "INDEX", "INDEXES", "INNER", "INPATH", "INPUTFORMAT", 
      "INSERT", "INTERSECT", "INTERVAL", "INTO", "IS", "ITEMS", "JOIN", 
      "KEYS", "LAST", "LATERAL", "LAZY", "LEADING", "LEFT", "LIKE", "LIMIT", 
      "LINES", "LIST", "LOAD", "LOCAL", "LOCATION", "LOCK", "LOCKS", "LOGICAL", 
      "MACRO", "MAP", "MATCHED", "MERGE", "MSCK", "NAMESPACE", "NAMESPACES", 
      "NATURAL", "NO", "NOT", "NULL", "NULLS", "OF", "ON", "ONLY", "OPTION", 
      "OPTIONS", "OR", "ORDER", "OUT", "OUTER", "OUTPUTFORMAT", "OVER", 
      "OVERLAPS", "OVERLAY", "OVERWRITE", "PARTITION", "PARTITIONED", "PARTITIONS", 
      "PERCENTLIT", "PIVOT", "PLACING", "POSITION", "PRECEDING", "PRIMARY", 
      "PRINCIPALS", "PROPERTIES", "PURGE", "QUERY", "RANGE", "RECORDREADER", 
      "RECORDWRITER", "RECOVER", "REDUCE", "REFERENCES", "REFRESH", "RENAME", 
      "REPAIR", "REPLACE", "RESET", "RESTRICT", "REVOKE", "RIGHT", "RLIKE", 
      "ROLE", "ROLES", "ROLLBACK", "ROLLUP", "ROW", "ROWS", "SCHEMA", "SELECT", 
      "SEMI", "SEPARATED", "SERDE", "SERDEPROPERTIES", "SESSION_USER", "SET", 
      "SETMINUS", "SETS", "SHOW", "SKEWED", "SOME", "SORT", "SORTED", "START", 
      "STATISTICS", "STORED", "STRATIFY", "STRUCT", "SUBSTR", "SUBSTRING", 
      "TABLE", "TABLES", "TABLESAMPLE", "TBLPROPERTIES", "TEMPORARY", "TERMINATED", 
      "THEN", "TO", "TOUCH", "TRAILING", "TRANSACTION", "TRANSACTIONS", 
      "TRANSFORM", "TRIM", "TRUE", "TRUNCATE", "TYPE", "UNARCHIVE", "UNBOUNDED", 
      "UNCACHE", "UNION", "UNIQUE", "UNKNOWN", "UNLOCK", "UNSET", "UPDATE", 
      "USE", "USER", "USING", "VALUES", "VIEW", "VIEWS", "WHEN", "WHERE", 
      "WINDOW", "WITH", "EQ", "NSEQ", "NEQ", "NEQJ", "LT", "LTE", "GT", 
      "GTE", "PLUS", "MINUS", "ASTERISK", "SLASH", "PERCENT", "TILDE", "AMPERSAND", 
      "PIPE", "CONCAT_PIPE", "HAT", "STRING", "BIGINT_LITERAL", "SMALLINT_LITERAL", 
      "TINYINT_LITERAL", "INTEGER_VALUE", "EXPONENT_VALUE", "DECIMAL_VALUE", 
      "DOUBLE_LITERAL", "BIGDECIMAL_LITERAL", "IDENTIFIER", "BACKQUOTED_IDENTIFIER", 
      "SIMPLE_COMMENT", "BRACKETED_EMPTY_COMMENT", "BRACKETED_COMMENT", 
      "WS", "UNRECOGNIZED"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,289,917,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
  	7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,
  	14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,
  	21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,
  	28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,
  	35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,
  	42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,
  	49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,
  	56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,
  	63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,1,0,1,
  	0,5,0,143,8,0,10,0,12,0,146,9,0,1,0,1,0,1,1,1,1,1,1,1,2,1,2,1,3,1,3,1,
  	3,1,4,1,4,1,4,1,5,1,5,1,5,1,5,1,5,5,5,166,8,5,10,5,12,5,169,9,5,3,5,171,
  	8,5,1,5,1,5,1,5,1,5,1,5,5,5,178,8,5,10,5,12,5,181,9,5,3,5,183,8,5,1,5,
  	1,5,1,5,3,5,188,8,5,3,5,190,8,5,1,6,1,6,1,7,1,7,1,7,1,7,1,7,1,7,1,7,3,
  	7,201,8,7,1,8,1,8,3,8,205,8,8,1,8,1,8,3,8,209,8,8,1,9,1,9,3,9,213,8,9,
  	1,9,3,9,216,8,9,1,10,1,10,3,10,220,8,10,1,10,1,10,1,11,1,11,1,11,1,12,
  	1,12,1,12,1,12,5,12,231,8,12,10,12,12,12,234,9,12,1,13,1,13,1,14,1,14,
  	1,15,1,15,1,15,1,15,1,16,1,16,1,16,5,16,247,8,16,10,16,12,16,250,9,16,
  	1,17,1,17,1,17,1,17,5,17,256,8,17,10,17,12,17,259,9,17,1,17,1,17,1,18,
  	1,18,3,18,265,8,18,1,19,1,19,1,19,1,19,5,19,271,8,19,10,19,12,19,274,
  	9,19,1,19,1,19,1,20,1,20,3,20,280,8,20,1,21,1,21,1,21,1,21,1,21,1,21,
  	1,21,1,21,1,21,1,21,1,21,1,21,1,21,3,21,295,8,21,1,22,3,22,298,8,22,1,
  	22,1,22,3,22,302,8,22,3,22,304,8,22,1,23,1,23,1,23,5,23,309,8,23,10,23,
  	12,23,312,9,23,1,24,1,24,1,24,5,24,317,8,24,10,24,12,24,320,9,24,1,25,
  	1,25,3,25,324,8,25,1,25,1,25,3,25,328,8,25,3,25,330,8,25,1,26,1,26,1,
  	26,5,26,335,8,26,10,26,12,26,338,9,26,1,27,1,27,1,28,1,28,1,28,1,28,1,
  	28,3,28,347,8,28,3,28,349,8,28,1,28,1,28,1,28,1,28,1,28,1,28,5,28,357,
  	8,28,10,28,12,28,360,9,28,1,29,3,29,363,8,29,1,29,1,29,1,29,1,29,1,29,
  	1,29,3,29,371,8,29,1,29,1,29,1,29,1,29,1,29,5,29,378,8,29,10,29,12,29,
  	381,9,29,1,29,1,29,1,29,3,29,386,8,29,1,29,1,29,1,29,1,29,1,29,1,29,3,
  	29,394,8,29,1,29,1,29,1,29,3,29,399,8,29,1,29,1,29,1,29,1,29,3,29,405,
  	8,29,1,29,1,29,3,29,409,8,29,1,29,1,29,1,29,3,29,414,8,29,1,29,1,29,1,
  	29,3,29,419,8,29,1,29,1,29,1,29,3,29,424,8,29,1,30,1,30,1,30,1,30,3,30,
  	430,8,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,
  	1,30,1,30,1,30,1,30,1,30,1,30,1,30,5,30,451,8,30,10,30,12,30,454,9,30,
  	1,31,1,31,1,31,1,31,4,31,460,8,31,11,31,12,31,461,1,31,1,31,3,31,466,
  	8,31,1,31,1,31,1,31,1,31,1,31,4,31,473,8,31,11,31,12,31,474,1,31,1,31,
  	3,31,479,8,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,
  	1,31,1,31,1,31,5,31,495,8,31,10,31,12,31,498,9,31,3,31,500,8,31,1,31,
  	1,31,1,31,1,31,1,31,1,31,3,31,508,8,31,1,31,1,31,1,31,1,31,1,31,1,31,
  	1,31,3,31,517,8,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,
  	1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,4,31,538,8,31,11,31,12,31,
  	539,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,5,31,553,8,
  	31,10,31,12,31,556,9,31,3,31,558,8,31,1,31,1,31,1,31,1,31,1,31,1,31,1,
  	31,3,31,567,8,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,5,31,577,8,31,
  	10,31,12,31,580,9,31,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,4,32,590,
  	8,32,11,32,12,32,591,3,32,594,8,32,1,33,1,33,1,34,1,34,1,35,1,35,1,36,
  	1,36,1,37,1,37,1,37,3,37,607,8,37,1,38,1,38,3,38,611,8,38,1,39,1,39,1,
  	39,4,39,616,8,39,11,39,12,39,617,1,40,1,40,1,40,3,40,623,8,40,1,41,1,
  	41,1,41,1,41,1,41,1,42,3,42,631,8,42,1,42,1,42,3,42,635,8,42,1,43,1,43,
  	1,43,3,43,640,8,43,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,
  	1,44,1,44,1,44,1,44,1,44,3,44,657,8,44,1,44,1,44,3,44,661,8,44,1,44,1,
  	44,1,44,1,44,1,44,5,44,668,8,44,10,44,12,44,671,9,44,1,44,3,44,674,8,
  	44,3,44,676,8,44,1,45,1,45,1,45,5,45,681,8,45,10,45,12,45,684,9,45,1,
  	46,1,46,1,46,1,46,3,46,690,8,46,1,46,3,46,693,8,46,1,46,3,46,696,8,46,
  	1,47,1,47,1,47,5,47,701,8,47,10,47,12,47,704,9,47,1,48,1,48,1,48,1,48,
  	3,48,710,8,48,1,48,3,48,713,8,48,1,49,1,49,1,49,5,49,718,8,49,10,49,12,
  	49,721,9,49,1,50,1,50,1,50,1,50,1,50,3,50,728,8,50,1,50,3,50,731,8,50,
  	1,51,1,51,1,51,1,51,1,51,1,52,1,52,1,52,1,52,5,52,742,8,52,10,52,12,52,
  	745,9,52,1,53,1,53,1,53,1,53,1,54,1,54,1,54,1,54,1,54,1,54,1,54,1,54,
  	1,54,1,54,1,54,5,54,762,8,54,10,54,12,54,765,9,54,1,54,1,54,1,54,1,54,
  	1,54,5,54,772,8,54,10,54,12,54,775,9,54,3,54,777,8,54,1,54,1,54,1,54,
  	1,54,1,54,5,54,784,8,54,10,54,12,54,787,9,54,3,54,789,8,54,3,54,791,8,
  	54,1,54,3,54,794,8,54,1,54,3,54,797,8,54,1,55,1,55,1,55,1,55,1,55,1,55,
  	1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,3,55,815,8,55,1,56,
  	1,56,1,56,1,56,1,56,1,56,1,56,3,56,824,8,56,1,57,1,57,1,57,5,57,829,8,
  	57,10,57,12,57,832,9,57,1,58,1,58,1,58,1,58,3,58,838,8,58,1,59,1,59,1,
  	59,5,59,843,8,59,10,59,12,59,846,9,59,1,60,1,60,1,60,1,61,1,61,4,61,853,
  	8,61,11,61,12,61,854,1,61,3,61,858,8,61,1,62,1,62,3,62,862,8,62,1,63,
  	1,63,1,63,1,63,3,63,868,8,63,1,64,1,64,1,65,3,65,873,8,65,1,65,1,65,3,
  	65,877,8,65,1,65,1,65,3,65,881,8,65,1,65,1,65,3,65,885,8,65,1,65,1,65,
  	3,65,889,8,65,1,65,1,65,3,65,893,8,65,1,65,1,65,3,65,897,8,65,1,65,3,
  	65,900,8,65,1,66,1,66,1,66,1,66,1,66,1,66,1,66,3,66,909,8,66,1,67,1,67,
  	1,68,1,68,1,69,1,69,1,69,0,3,56,60,62,70,0,2,4,6,8,10,12,14,16,18,20,
  	22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,
  	68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,
  	112,114,116,118,120,122,124,126,128,130,132,134,136,138,0,22,2,0,20,20,
  	65,65,2,0,91,91,123,123,2,0,11,11,70,70,3,0,86,86,234,234,242,242,2,0,
  	264,265,269,269,2,0,72,72,266,268,2,0,264,265,272,272,2,0,54,54,56,56,
  	1,0,256,263,2,0,72,72,264,273,4,0,14,14,109,109,147,147,155,155,2,0,86,
  	86,234,234,1,0,264,265,2,0,278,278,280,280,2,0,71,71,164,164,2,0,156,
  	156,211,211,2,0,92,92,171,171,1,0,279,280,2,0,73,73,205,205,47,0,9,10,
  	12,13,15,15,17,18,20,21,23,23,25,29,32,32,34,37,39,39,41,47,49,49,52,
  	53,58,69,71,73,77,77,79,85,88,88,90,92,95,96,99,101,104,104,106,108,110,
  	111,113,115,117,117,120,120,122,125,128,144,146,146,149,150,153,154,157,
  	157,159,160,162,171,173,181,183,189,191,198,200,203,205,209,211,219,221,
  	225,228,228,230,239,243,246,249,251,254,254,15,0,15,15,51,51,78,78,98,
  	98,112,112,116,116,121,121,127,127,145,145,151,151,190,190,200,200,206,
  	206,240,240,248,248,16,0,9,14,16,50,52,77,79,97,99,111,113,115,117,120,
  	122,126,128,144,146,150,152,189,191,199,201,205,207,239,241,247,249,255,
  	1007,0,140,1,0,0,0,2,149,1,0,0,0,4,152,1,0,0,0,6,154,1,0,0,0,8,157,1,
  	0,0,0,10,170,1,0,0,0,12,191,1,0,0,0,14,200,1,0,0,0,16,202,1,0,0,0,18,
  	210,1,0,0,0,20,217,1,0,0,0,22,223,1,0,0,0,24,226,1,0,0,0,26,235,1,0,0,
  	0,28,237,1,0,0,0,30,239,1,0,0,0,32,243,1,0,0,0,34,251,1,0,0,0,36,262,
  	1,0,0,0,38,266,1,0,0,0,40,277,1,0,0,0,42,294,1,0,0,0,44,303,1,0,0,0,46,
  	305,1,0,0,0,48,313,1,0,0,0,50,321,1,0,0,0,52,331,1,0,0,0,54,339,1,0,0,
  	0,56,348,1,0,0,0,58,423,1,0,0,0,60,429,1,0,0,0,62,566,1,0,0,0,64,593,
  	1,0,0,0,66,595,1,0,0,0,68,597,1,0,0,0,70,599,1,0,0,0,72,601,1,0,0,0,74,
  	603,1,0,0,0,76,608,1,0,0,0,78,615,1,0,0,0,80,619,1,0,0,0,82,624,1,0,0,
  	0,84,634,1,0,0,0,86,639,1,0,0,0,88,675,1,0,0,0,90,677,1,0,0,0,92,685,
  	1,0,0,0,94,697,1,0,0,0,96,705,1,0,0,0,98,714,1,0,0,0,100,722,1,0,0,0,
  	102,732,1,0,0,0,104,737,1,0,0,0,106,746,1,0,0,0,108,796,1,0,0,0,110,814,
  	1,0,0,0,112,823,1,0,0,0,114,825,1,0,0,0,116,837,1,0,0,0,118,839,1,0,0,
  	0,120,847,1,0,0,0,122,857,1,0,0,0,124,861,1,0,0,0,126,867,1,0,0,0,128,
  	869,1,0,0,0,130,899,1,0,0,0,132,908,1,0,0,0,134,910,1,0,0,0,136,912,1,
  	0,0,0,138,914,1,0,0,0,140,144,3,4,2,0,141,143,5,1,0,0,142,141,1,0,0,0,
  	143,146,1,0,0,0,144,142,1,0,0,0,144,145,1,0,0,0,145,147,1,0,0,0,146,144,
  	1,0,0,0,147,148,5,0,0,1,148,1,1,0,0,0,149,150,3,88,44,0,150,151,5,0,0,
  	1,151,3,1,0,0,0,152,153,3,8,4,0,153,5,1,0,0,0,154,155,5,42,0,0,155,156,
  	5,274,0,0,156,7,1,0,0,0,157,158,3,12,6,0,158,159,3,10,5,0,159,9,1,0,0,
  	0,160,161,5,156,0,0,161,162,5,27,0,0,162,167,3,16,8,0,163,164,5,2,0,0,
  	164,166,3,16,8,0,165,163,1,0,0,0,166,169,1,0,0,0,167,165,1,0,0,0,167,
  	168,1,0,0,0,168,171,1,0,0,0,169,167,1,0,0,0,170,160,1,0,0,0,170,171,1,
  	0,0,0,171,182,1,0,0,0,172,173,5,211,0,0,173,174,5,27,0,0,174,179,3,16,
  	8,0,175,176,5,2,0,0,176,178,3,16,8,0,177,175,1,0,0,0,178,181,1,0,0,0,
  	179,177,1,0,0,0,179,180,1,0,0,0,180,183,1,0,0,0,181,179,1,0,0,0,182,172,
  	1,0,0,0,182,183,1,0,0,0,183,189,1,0,0,0,184,187,5,129,0,0,185,188,5,11,
  	0,0,186,188,3,54,27,0,187,185,1,0,0,0,187,186,1,0,0,0,188,190,1,0,0,0,
  	189,184,1,0,0,0,189,190,1,0,0,0,190,11,1,0,0,0,191,192,3,14,7,0,192,13,
  	1,0,0,0,193,201,3,18,9,0,194,195,5,220,0,0,195,201,3,48,24,0,196,197,
  	5,3,0,0,197,198,3,8,4,0,198,199,5,4,0,0,199,201,1,0,0,0,200,193,1,0,0,
  	0,200,194,1,0,0,0,200,196,1,0,0,0,201,15,1,0,0,0,202,204,3,54,27,0,203,
  	205,7,0,0,0,204,203,1,0,0,0,204,205,1,0,0,0,205,208,1,0,0,0,206,207,5,
  	149,0,0,207,209,7,1,0,0,208,206,1,0,0,0,208,209,1,0,0,0,209,17,1,0,0,
  	0,210,212,3,20,10,0,211,213,3,24,12,0,212,211,1,0,0,0,212,213,1,0,0,0,
  	213,215,1,0,0,0,214,216,3,22,11,0,215,214,1,0,0,0,215,216,1,0,0,0,216,
  	19,1,0,0,0,217,219,5,199,0,0,218,220,3,26,13,0,219,218,1,0,0,0,219,220,
  	1,0,0,0,220,221,1,0,0,0,221,222,3,52,26,0,222,21,1,0,0,0,223,224,5,253,
  	0,0,224,225,3,56,28,0,225,23,1,0,0,0,226,227,5,97,0,0,227,232,3,28,14,
  	0,228,229,5,2,0,0,229,231,3,28,14,0,230,228,1,0,0,0,231,234,1,0,0,0,232,
  	230,1,0,0,0,232,233,1,0,0,0,233,25,1,0,0,0,234,232,1,0,0,0,235,236,7,
  	2,0,0,236,27,1,0,0,0,237,238,3,42,21,0,238,29,1,0,0,0,239,240,5,3,0,0,
  	240,241,3,32,16,0,241,242,5,4,0,0,242,31,1,0,0,0,243,248,3,120,60,0,244,
  	245,5,2,0,0,245,247,3,120,60,0,246,244,1,0,0,0,247,250,1,0,0,0,248,246,
  	1,0,0,0,248,249,1,0,0,0,249,33,1,0,0,0,250,248,1,0,0,0,251,252,5,3,0,
  	0,252,257,3,36,18,0,253,254,5,2,0,0,254,256,3,36,18,0,255,253,1,0,0,0,
  	256,259,1,0,0,0,257,255,1,0,0,0,257,258,1,0,0,0,258,260,1,0,0,0,259,257,
  	1,0,0,0,260,261,5,4,0,0,261,35,1,0,0,0,262,264,3,120,60,0,263,265,7,0,
  	0,0,264,263,1,0,0,0,264,265,1,0,0,0,265,37,1,0,0,0,266,267,5,3,0,0,267,
  	272,3,40,20,0,268,269,5,2,0,0,269,271,3,40,20,0,270,268,1,0,0,0,271,274,
  	1,0,0,0,272,270,1,0,0,0,272,273,1,0,0,0,273,275,1,0,0,0,274,272,1,0,0,
  	0,275,276,5,4,0,0,276,39,1,0,0,0,277,279,3,124,62,0,278,280,3,6,3,0,279,
  	278,1,0,0,0,279,280,1,0,0,0,280,41,1,0,0,0,281,282,3,48,24,0,282,283,
  	3,44,22,0,283,295,1,0,0,0,284,285,5,3,0,0,285,286,3,8,4,0,286,287,5,4,
  	0,0,287,288,3,44,22,0,288,295,1,0,0,0,289,290,5,3,0,0,290,291,3,28,14,
  	0,291,292,5,4,0,0,292,293,3,44,22,0,293,295,1,0,0,0,294,281,1,0,0,0,294,
  	284,1,0,0,0,294,289,1,0,0,0,295,43,1,0,0,0,296,298,5,19,0,0,297,296,1,
  	0,0,0,297,298,1,0,0,0,298,299,1,0,0,0,299,301,3,126,63,0,300,302,3,30,
  	15,0,301,300,1,0,0,0,301,302,1,0,0,0,302,304,1,0,0,0,303,297,1,0,0,0,
  	303,304,1,0,0,0,304,45,1,0,0,0,305,310,3,48,24,0,306,307,5,2,0,0,307,
  	309,3,48,24,0,308,306,1,0,0,0,309,312,1,0,0,0,310,308,1,0,0,0,310,311,
  	1,0,0,0,311,47,1,0,0,0,312,310,1,0,0,0,313,318,3,120,60,0,314,315,5,5,
  	0,0,315,317,3,120,60,0,316,314,1,0,0,0,317,320,1,0,0,0,318,316,1,0,0,
  	0,318,319,1,0,0,0,319,49,1,0,0,0,320,318,1,0,0,0,321,329,3,54,27,0,322,
  	324,5,19,0,0,323,322,1,0,0,0,323,324,1,0,0,0,324,327,1,0,0,0,325,328,
  	3,120,60,0,326,328,3,30,15,0,327,325,1,0,0,0,327,326,1,0,0,0,328,330,
  	1,0,0,0,329,323,1,0,0,0,329,330,1,0,0,0,330,51,1,0,0,0,331,336,3,50,25,
  	0,332,333,5,2,0,0,333,335,3,50,25,0,334,332,1,0,0,0,335,338,1,0,0,0,336,
  	334,1,0,0,0,336,337,1,0,0,0,337,53,1,0,0,0,338,336,1,0,0,0,339,340,3,
  	56,28,0,340,55,1,0,0,0,341,342,6,28,-1,0,342,343,5,147,0,0,343,349,3,
  	56,28,4,344,346,3,60,30,0,345,347,3,58,29,0,346,345,1,0,0,0,346,347,1,
  	0,0,0,347,349,1,0,0,0,348,341,1,0,0,0,348,344,1,0,0,0,349,358,1,0,0,0,
  	350,351,10,2,0,0,351,352,5,14,0,0,352,357,3,56,28,3,353,354,10,1,0,0,
  	354,355,5,155,0,0,355,357,3,56,28,2,356,350,1,0,0,0,356,353,1,0,0,0,357,
  	360,1,0,0,0,358,356,1,0,0,0,358,359,1,0,0,0,359,57,1,0,0,0,360,358,1,
  	0,0,0,361,363,5,147,0,0,362,361,1,0,0,0,362,363,1,0,0,0,363,364,1,0,0,
  	0,364,365,5,23,0,0,365,366,3,60,30,0,366,367,5,14,0,0,367,368,3,60,30,
  	0,368,424,1,0,0,0,369,371,5,147,0,0,370,369,1,0,0,0,370,371,1,0,0,0,371,
  	372,1,0,0,0,372,373,5,109,0,0,373,374,5,3,0,0,374,379,3,54,27,0,375,376,
  	5,2,0,0,376,378,3,54,27,0,377,375,1,0,0,0,378,381,1,0,0,0,379,377,1,0,
  	0,0,379,380,1,0,0,0,380,382,1,0,0,0,381,379,1,0,0,0,382,383,5,4,0,0,383,
  	424,1,0,0,0,384,386,5,147,0,0,385,384,1,0,0,0,385,386,1,0,0,0,386,387,
  	1,0,0,0,387,388,5,109,0,0,388,389,5,3,0,0,389,390,3,8,4,0,390,391,5,4,
  	0,0,391,424,1,0,0,0,392,394,5,147,0,0,393,392,1,0,0,0,393,394,1,0,0,0,
  	394,395,1,0,0,0,395,396,5,191,0,0,396,424,3,60,30,0,397,399,5,147,0,0,
  	398,397,1,0,0,0,398,399,1,0,0,0,399,400,1,0,0,0,400,401,5,128,0,0,401,
  	404,3,60,30,0,402,403,5,76,0,0,403,405,5,274,0,0,404,402,1,0,0,0,404,
  	405,1,0,0,0,405,424,1,0,0,0,406,408,5,119,0,0,407,409,5,147,0,0,408,407,
  	1,0,0,0,408,409,1,0,0,0,409,410,1,0,0,0,410,424,5,148,0,0,411,413,5,119,
  	0,0,412,414,5,147,0,0,413,412,1,0,0,0,413,414,1,0,0,0,414,415,1,0,0,0,
  	415,424,7,3,0,0,416,418,5,119,0,0,417,419,5,147,0,0,418,417,1,0,0,0,418,
  	419,1,0,0,0,419,420,1,0,0,0,420,421,5,70,0,0,421,422,5,97,0,0,422,424,
  	3,60,30,0,423,362,1,0,0,0,423,370,1,0,0,0,423,385,1,0,0,0,423,393,1,0,
  	0,0,423,398,1,0,0,0,423,406,1,0,0,0,423,411,1,0,0,0,423,416,1,0,0,0,424,
  	59,1,0,0,0,425,426,6,30,-1,0,426,430,3,62,31,0,427,428,7,4,0,0,428,430,
  	3,60,30,7,429,425,1,0,0,0,429,427,1,0,0,0,430,452,1,0,0,0,431,432,10,
  	6,0,0,432,433,7,5,0,0,433,451,3,60,30,7,434,435,10,5,0,0,435,436,7,6,
  	0,0,436,451,3,60,30,6,437,438,10,4,0,0,438,439,5,270,0,0,439,451,3,60,
  	30,5,440,441,10,3,0,0,441,442,5,273,0,0,442,451,3,60,30,4,443,444,10,
  	2,0,0,444,445,5,271,0,0,445,451,3,60,30,3,446,447,10,1,0,0,447,448,3,
  	66,33,0,448,449,3,60,30,2,449,451,1,0,0,0,450,431,1,0,0,0,450,434,1,0,
  	0,0,450,437,1,0,0,0,450,440,1,0,0,0,450,443,1,0,0,0,450,446,1,0,0,0,451,
  	454,1,0,0,0,452,450,1,0,0,0,452,453,1,0,0,0,453,61,1,0,0,0,454,452,1,
  	0,0,0,455,456,6,31,-1,0,456,567,7,7,0,0,457,459,5,30,0,0,458,460,3,102,
  	51,0,459,458,1,0,0,0,460,461,1,0,0,0,461,459,1,0,0,0,461,462,1,0,0,0,
  	462,465,1,0,0,0,463,464,5,74,0,0,464,466,3,54,27,0,465,463,1,0,0,0,465,
  	466,1,0,0,0,466,467,1,0,0,0,467,468,5,75,0,0,468,567,1,0,0,0,469,470,
  	5,30,0,0,470,472,3,54,27,0,471,473,3,102,51,0,472,471,1,0,0,0,473,474,
  	1,0,0,0,474,472,1,0,0,0,474,475,1,0,0,0,475,478,1,0,0,0,476,477,5,74,
  	0,0,477,479,3,54,27,0,478,476,1,0,0,0,478,479,1,0,0,0,479,480,1,0,0,0,
  	480,481,5,75,0,0,481,567,1,0,0,0,482,483,5,31,0,0,483,484,5,3,0,0,484,
  	485,3,54,27,0,485,486,5,19,0,0,486,487,3,88,44,0,487,488,5,4,0,0,488,
  	567,1,0,0,0,489,490,5,217,0,0,490,499,5,3,0,0,491,496,3,50,25,0,492,493,
  	5,2,0,0,493,495,3,50,25,0,494,492,1,0,0,0,495,498,1,0,0,0,496,494,1,0,
  	0,0,496,497,1,0,0,0,497,500,1,0,0,0,498,496,1,0,0,0,499,491,1,0,0,0,499,
  	500,1,0,0,0,500,501,1,0,0,0,501,567,5,4,0,0,502,503,5,91,0,0,503,504,
  	5,3,0,0,504,507,3,54,27,0,505,506,5,107,0,0,506,508,5,149,0,0,507,505,
  	1,0,0,0,507,508,1,0,0,0,508,509,1,0,0,0,509,510,5,4,0,0,510,567,1,0,0,
  	0,511,512,5,123,0,0,512,513,5,3,0,0,513,516,3,54,27,0,514,515,5,107,0,
  	0,515,517,5,149,0,0,516,514,1,0,0,0,516,517,1,0,0,0,517,518,1,0,0,0,518,
  	519,5,4,0,0,519,567,1,0,0,0,520,521,5,170,0,0,521,522,5,3,0,0,522,523,
  	3,60,30,0,523,524,5,109,0,0,524,525,3,60,30,0,525,526,5,4,0,0,526,567,
  	1,0,0,0,527,567,3,64,32,0,528,567,5,266,0,0,529,530,3,118,59,0,530,531,
  	5,5,0,0,531,532,5,266,0,0,532,567,1,0,0,0,533,534,5,3,0,0,534,537,3,50,
  	25,0,535,536,5,2,0,0,536,538,3,50,25,0,537,535,1,0,0,0,538,539,1,0,0,
  	0,539,537,1,0,0,0,539,540,1,0,0,0,540,541,1,0,0,0,541,542,5,4,0,0,542,
  	567,1,0,0,0,543,544,5,3,0,0,544,545,3,8,4,0,545,546,5,4,0,0,546,567,1,
  	0,0,0,547,548,3,116,58,0,548,557,5,3,0,0,549,554,3,54,27,0,550,551,5,
  	2,0,0,551,553,3,54,27,0,552,550,1,0,0,0,553,556,1,0,0,0,554,552,1,0,0,
  	0,554,555,1,0,0,0,555,558,1,0,0,0,556,554,1,0,0,0,557,549,1,0,0,0,557,
  	558,1,0,0,0,558,559,1,0,0,0,559,560,5,4,0,0,560,567,1,0,0,0,561,567,3,
  	124,62,0,562,563,5,3,0,0,563,564,3,54,27,0,564,565,5,4,0,0,565,567,1,
  	0,0,0,566,455,1,0,0,0,566,457,1,0,0,0,566,469,1,0,0,0,566,482,1,0,0,0,
  	566,489,1,0,0,0,566,502,1,0,0,0,566,511,1,0,0,0,566,520,1,0,0,0,566,527,
  	1,0,0,0,566,528,1,0,0,0,566,529,1,0,0,0,566,533,1,0,0,0,566,543,1,0,0,
  	0,566,547,1,0,0,0,566,561,1,0,0,0,566,562,1,0,0,0,567,578,1,0,0,0,568,
  	569,10,4,0,0,569,570,5,6,0,0,570,571,3,60,30,0,571,572,5,7,0,0,572,577,
  	1,0,0,0,573,574,10,2,0,0,574,575,5,5,0,0,575,577,3,124,62,0,576,568,1,
  	0,0,0,576,573,1,0,0,0,577,580,1,0,0,0,578,576,1,0,0,0,578,579,1,0,0,0,
  	579,63,1,0,0,0,580,578,1,0,0,0,581,594,5,148,0,0,582,594,3,74,37,0,583,
  	584,3,124,62,0,584,585,5,274,0,0,585,594,1,0,0,0,586,594,3,130,65,0,587,
  	594,3,72,36,0,588,590,5,274,0,0,589,588,1,0,0,0,590,591,1,0,0,0,591,589,
  	1,0,0,0,591,592,1,0,0,0,592,594,1,0,0,0,593,581,1,0,0,0,593,582,1,0,0,
  	0,593,583,1,0,0,0,593,586,1,0,0,0,593,587,1,0,0,0,593,589,1,0,0,0,594,
  	65,1,0,0,0,595,596,7,8,0,0,596,67,1,0,0,0,597,598,7,9,0,0,598,69,1,0,
  	0,0,599,600,7,10,0,0,600,71,1,0,0,0,601,602,7,11,0,0,602,73,1,0,0,0,603,
  	606,5,117,0,0,604,607,3,76,38,0,605,607,3,80,40,0,606,604,1,0,0,0,606,
  	605,1,0,0,0,606,607,1,0,0,0,607,75,1,0,0,0,608,610,3,78,39,0,609,611,
  	3,82,41,0,610,609,1,0,0,0,610,611,1,0,0,0,611,77,1,0,0,0,612,613,3,84,
  	42,0,613,614,3,124,62,0,614,616,1,0,0,0,615,612,1,0,0,0,616,617,1,0,0,
  	0,617,615,1,0,0,0,617,618,1,0,0,0,618,79,1,0,0,0,619,622,3,82,41,0,620,
  	623,3,78,39,0,621,623,3,82,41,0,622,620,1,0,0,0,622,621,1,0,0,0,622,623,
  	1,0,0,0,623,81,1,0,0,0,624,625,3,84,42,0,625,626,3,124,62,0,626,627,5,
  	227,0,0,627,628,3,124,62,0,628,83,1,0,0,0,629,631,7,12,0,0,630,629,1,
  	0,0,0,630,631,1,0,0,0,631,632,1,0,0,0,632,635,7,13,0,0,633,635,5,274,
  	0,0,634,630,1,0,0,0,634,633,1,0,0,0,635,85,1,0,0,0,636,640,5,91,0,0,637,
  	638,5,10,0,0,638,640,3,120,60,0,639,636,1,0,0,0,639,637,1,0,0,0,640,87,
  	1,0,0,0,641,642,5,18,0,0,642,643,5,260,0,0,643,644,3,88,44,0,644,645,
  	5,262,0,0,645,676,1,0,0,0,646,647,5,139,0,0,647,648,5,260,0,0,648,649,
  	3,88,44,0,649,650,5,2,0,0,650,651,3,88,44,0,651,652,5,262,0,0,652,676,
  	1,0,0,0,653,660,5,217,0,0,654,656,5,260,0,0,655,657,3,98,49,0,656,655,
  	1,0,0,0,656,657,1,0,0,0,657,658,1,0,0,0,658,661,5,262,0,0,659,661,5,258,
  	0,0,660,654,1,0,0,0,660,659,1,0,0,0,661,676,1,0,0,0,662,673,3,124,62,
  	0,663,664,5,3,0,0,664,669,5,278,0,0,665,666,5,2,0,0,666,668,5,278,0,0,
  	667,665,1,0,0,0,668,671,1,0,0,0,669,667,1,0,0,0,669,670,1,0,0,0,670,672,
  	1,0,0,0,671,669,1,0,0,0,672,674,5,4,0,0,673,663,1,0,0,0,673,674,1,0,0,
  	0,674,676,1,0,0,0,675,641,1,0,0,0,675,646,1,0,0,0,675,653,1,0,0,0,675,
  	662,1,0,0,0,676,89,1,0,0,0,677,682,3,92,46,0,678,679,5,2,0,0,679,681,
  	3,92,46,0,680,678,1,0,0,0,681,684,1,0,0,0,682,680,1,0,0,0,682,683,1,0,
  	0,0,683,91,1,0,0,0,684,682,1,0,0,0,685,686,3,48,24,0,686,689,3,88,44,
  	0,687,688,5,147,0,0,688,690,5,148,0,0,689,687,1,0,0,0,689,690,1,0,0,0,
  	690,692,1,0,0,0,691,693,3,6,3,0,692,691,1,0,0,0,692,693,1,0,0,0,693,695,
  	1,0,0,0,694,696,3,86,43,0,695,694,1,0,0,0,695,696,1,0,0,0,696,93,1,0,
  	0,0,697,702,3,96,48,0,698,699,5,2,0,0,699,701,3,96,48,0,700,698,1,0,0,
  	0,701,704,1,0,0,0,702,700,1,0,0,0,702,703,1,0,0,0,703,95,1,0,0,0,704,
  	702,1,0,0,0,705,706,3,120,60,0,706,709,3,88,44,0,707,708,5,147,0,0,708,
  	710,5,148,0,0,709,707,1,0,0,0,709,710,1,0,0,0,710,712,1,0,0,0,711,713,
  	3,6,3,0,712,711,1,0,0,0,712,713,1,0,0,0,713,97,1,0,0,0,714,719,3,100,
  	50,0,715,716,5,2,0,0,716,718,3,100,50,0,717,715,1,0,0,0,718,721,1,0,0,
  	0,719,717,1,0,0,0,719,720,1,0,0,0,720,99,1,0,0,0,721,719,1,0,0,0,722,
  	723,3,124,62,0,723,724,5,8,0,0,724,727,3,88,44,0,725,726,5,147,0,0,726,
  	728,5,148,0,0,727,725,1,0,0,0,727,728,1,0,0,0,728,730,1,0,0,0,729,731,
  	3,6,3,0,730,729,1,0,0,0,730,731,1,0,0,0,731,101,1,0,0,0,732,733,5,252,
  	0,0,733,734,3,54,27,0,734,735,5,226,0,0,735,736,3,54,27,0,736,103,1,0,
  	0,0,737,738,5,254,0,0,738,743,3,106,53,0,739,740,5,2,0,0,740,742,3,106,
  	53,0,741,739,1,0,0,0,742,745,1,0,0,0,743,741,1,0,0,0,743,744,1,0,0,0,
  	744,105,1,0,0,0,745,743,1,0,0,0,746,747,3,120,60,0,747,748,5,19,0,0,748,
  	749,3,108,54,0,749,107,1,0,0,0,750,797,3,120,60,0,751,752,5,3,0,0,752,
  	753,3,120,60,0,753,754,5,4,0,0,754,797,1,0,0,0,755,790,5,3,0,0,756,757,
  	5,35,0,0,757,758,5,27,0,0,758,763,3,54,27,0,759,760,5,2,0,0,760,762,3,
  	54,27,0,761,759,1,0,0,0,762,765,1,0,0,0,763,761,1,0,0,0,763,764,1,0,0,
  	0,764,791,1,0,0,0,765,763,1,0,0,0,766,767,7,14,0,0,767,768,5,27,0,0,768,
  	773,3,54,27,0,769,770,5,2,0,0,770,772,3,54,27,0,771,769,1,0,0,0,772,775,
  	1,0,0,0,773,771,1,0,0,0,773,774,1,0,0,0,774,777,1,0,0,0,775,773,1,0,0,
  	0,776,766,1,0,0,0,776,777,1,0,0,0,777,788,1,0,0,0,778,779,7,15,0,0,779,
  	780,5,27,0,0,780,785,3,16,8,0,781,782,5,2,0,0,782,784,3,16,8,0,783,781,
  	1,0,0,0,784,787,1,0,0,0,785,783,1,0,0,0,785,786,1,0,0,0,786,789,1,0,0,
  	0,787,785,1,0,0,0,788,778,1,0,0,0,788,789,1,0,0,0,789,791,1,0,0,0,790,
  	756,1,0,0,0,790,776,1,0,0,0,791,793,1,0,0,0,792,794,3,110,55,0,793,792,
  	1,0,0,0,793,794,1,0,0,0,794,795,1,0,0,0,795,797,5,4,0,0,796,750,1,0,0,
  	0,796,751,1,0,0,0,796,755,1,0,0,0,797,109,1,0,0,0,798,799,5,177,0,0,799,
  	815,3,112,56,0,800,801,5,197,0,0,801,815,3,112,56,0,802,803,5,177,0,0,
  	803,804,5,23,0,0,804,805,3,112,56,0,805,806,5,14,0,0,806,807,3,112,56,
  	0,807,815,1,0,0,0,808,809,5,197,0,0,809,810,5,23,0,0,810,811,3,112,56,
  	0,811,812,5,14,0,0,812,813,3,112,56,0,813,815,1,0,0,0,814,798,1,0,0,0,
  	814,800,1,0,0,0,814,802,1,0,0,0,814,808,1,0,0,0,815,111,1,0,0,0,816,817,
  	5,238,0,0,817,824,7,16,0,0,818,819,5,53,0,0,819,824,5,196,0,0,820,821,
  	3,54,27,0,821,822,7,16,0,0,822,824,1,0,0,0,823,816,1,0,0,0,823,818,1,
  	0,0,0,823,820,1,0,0,0,824,113,1,0,0,0,825,830,3,118,59,0,826,827,5,2,
  	0,0,827,829,3,118,59,0,828,826,1,0,0,0,829,832,1,0,0,0,830,828,1,0,0,
  	0,830,831,1,0,0,0,831,115,1,0,0,0,832,830,1,0,0,0,833,838,3,118,59,0,
  	834,838,5,89,0,0,835,838,5,127,0,0,836,838,5,190,0,0,837,833,1,0,0,0,
  	837,834,1,0,0,0,837,835,1,0,0,0,837,836,1,0,0,0,838,117,1,0,0,0,839,844,
  	3,124,62,0,840,841,5,5,0,0,841,843,3,124,62,0,842,840,1,0,0,0,843,846,
  	1,0,0,0,844,842,1,0,0,0,844,845,1,0,0,0,845,119,1,0,0,0,846,844,1,0,0,
  	0,847,848,3,124,62,0,848,849,3,122,61,0,849,121,1,0,0,0,850,851,5,265,
  	0,0,851,853,3,124,62,0,852,850,1,0,0,0,853,854,1,0,0,0,854,852,1,0,0,
  	0,854,855,1,0,0,0,855,858,1,0,0,0,856,858,1,0,0,0,857,852,1,0,0,0,857,
  	856,1,0,0,0,858,123,1,0,0,0,859,862,3,126,63,0,860,862,3,136,68,0,861,
  	859,1,0,0,0,861,860,1,0,0,0,862,125,1,0,0,0,863,868,5,283,0,0,864,868,
  	3,128,64,0,865,868,3,134,67,0,866,868,3,138,69,0,867,863,1,0,0,0,867,
  	864,1,0,0,0,867,865,1,0,0,0,867,866,1,0,0,0,868,127,1,0,0,0,869,870,5,
  	284,0,0,870,129,1,0,0,0,871,873,5,265,0,0,872,871,1,0,0,0,872,873,1,0,
  	0,0,873,874,1,0,0,0,874,900,7,17,0,0,875,877,5,265,0,0,876,875,1,0,0,
  	0,876,877,1,0,0,0,877,878,1,0,0,0,878,900,5,278,0,0,879,881,5,265,0,0,
  	880,879,1,0,0,0,880,881,1,0,0,0,881,882,1,0,0,0,882,900,5,275,0,0,883,
  	885,5,265,0,0,884,883,1,0,0,0,884,885,1,0,0,0,885,886,1,0,0,0,886,900,
  	5,276,0,0,887,889,5,265,0,0,888,887,1,0,0,0,888,889,1,0,0,0,889,890,1,
  	0,0,0,890,900,5,277,0,0,891,893,5,265,0,0,892,891,1,0,0,0,892,893,1,0,
  	0,0,893,894,1,0,0,0,894,900,5,281,0,0,895,897,5,265,0,0,896,895,1,0,0,
  	0,896,897,1,0,0,0,897,898,1,0,0,0,898,900,5,282,0,0,899,872,1,0,0,0,899,
  	876,1,0,0,0,899,880,1,0,0,0,899,884,1,0,0,0,899,888,1,0,0,0,899,892,1,
  	0,0,0,899,896,1,0,0,0,900,131,1,0,0,0,901,902,5,236,0,0,902,909,3,88,
  	44,0,903,909,3,6,3,0,904,909,3,86,43,0,905,906,7,18,0,0,906,907,5,147,
  	0,0,907,909,5,148,0,0,908,901,1,0,0,0,908,903,1,0,0,0,908,904,1,0,0,0,
  	908,905,1,0,0,0,909,133,1,0,0,0,910,911,7,19,0,0,911,135,1,0,0,0,912,
  	913,7,20,0,0,913,137,1,0,0,0,914,915,7,21,0,0,915,139,1,0,0,0,112,144,
  	167,170,179,182,187,189,200,204,208,212,215,219,232,248,257,264,272,279,
  	294,297,301,303,310,318,323,327,329,336,346,348,356,358,362,370,379,385,
  	393,398,404,408,413,418,423,429,450,452,461,465,474,478,496,499,507,516,
  	539,554,557,566,576,578,591,593,606,610,617,622,630,634,639,656,660,669,
  	673,675,682,689,692,695,702,709,712,719,727,730,743,763,773,776,785,788,
  	790,793,796,814,823,830,837,844,854,857,861,867,872,876,880,884,888,892,
  	896,899,908
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  sql_parserParserStaticData = staticData.release();
}

}

sql_parserParser::sql_parserParser(TokenStream *input) : sql_parserParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

sql_parserParser::sql_parserParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  sql_parserParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *sql_parserParserStaticData->atn, sql_parserParserStaticData->decisionToDFA, sql_parserParserStaticData->sharedContextCache, options);
}

sql_parserParser::~sql_parserParser() {
  delete _interpreter;
}

const atn::ATN& sql_parserParser::getATN() const {
  return *sql_parserParserStaticData->atn;
}

std::string sql_parserParser::getGrammarFileName() const {
  return "sql_parser.g4";
}

const std::vector<std::string>& sql_parserParser::getRuleNames() const {
  return sql_parserParserStaticData->ruleNames;
}

const dfa::Vocabulary& sql_parserParser::getVocabulary() const {
  return sql_parserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView sql_parserParser::getSerializedATN() const {
  return sql_parserParserStaticData->serializedATN;
}


//----------------- SingleStatementContext ------------------------------------------------------------------

sql_parserParser::SingleStatementContext::SingleStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

sql_parserParser::StatementContext* sql_parserParser::SingleStatementContext::statement() {
  return getRuleContext<sql_parserParser::StatementContext>(0);
}

tree::TerminalNode* sql_parserParser::SingleStatementContext::EOF() {
  return getToken(sql_parserParser::EOF, 0);
}


size_t sql_parserParser::SingleStatementContext::getRuleIndex() const {
  return sql_parserParser::RuleSingleStatement;
}


std::any sql_parserParser::SingleStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitSingleStatement(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::SingleStatementContext* sql_parserParser::singleStatement() {
  SingleStatementContext *_localctx = _tracker.createInstance<SingleStatementContext>(_ctx, getState());
  enterRule(_localctx, 0, sql_parserParser::RuleSingleStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(140);
    statement();
    setState(144);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == sql_parserParser::T__0) {
      setState(141);
      match(sql_parserParser::T__0);
      setState(146);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(147);
    match(sql_parserParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SingleDataTypeContext ------------------------------------------------------------------

sql_parserParser::SingleDataTypeContext::SingleDataTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

sql_parserParser::DataTypeContext* sql_parserParser::SingleDataTypeContext::dataType() {
  return getRuleContext<sql_parserParser::DataTypeContext>(0);
}

tree::TerminalNode* sql_parserParser::SingleDataTypeContext::EOF() {
  return getToken(sql_parserParser::EOF, 0);
}


size_t sql_parserParser::SingleDataTypeContext::getRuleIndex() const {
  return sql_parserParser::RuleSingleDataType;
}


std::any sql_parserParser::SingleDataTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitSingleDataType(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::SingleDataTypeContext* sql_parserParser::singleDataType() {
  SingleDataTypeContext *_localctx = _tracker.createInstance<SingleDataTypeContext>(_ctx, getState());
  enterRule(_localctx, 2, sql_parserParser::RuleSingleDataType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(149);
    dataType();
    setState(150);
    match(sql_parserParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

sql_parserParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t sql_parserParser::StatementContext::getRuleIndex() const {
  return sql_parserParser::RuleStatement;
}

void sql_parserParser::StatementContext::copyFrom(StatementContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- StatementDefaultContext ------------------------------------------------------------------

sql_parserParser::QueryContext* sql_parserParser::StatementDefaultContext::query() {
  return getRuleContext<sql_parserParser::QueryContext>(0);
}

sql_parserParser::StatementDefaultContext::StatementDefaultContext(StatementContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::StatementDefaultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitStatementDefault(this);
  else
    return visitor->visitChildren(this);
}
sql_parserParser::StatementContext* sql_parserParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 4, sql_parserParser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    _localctx = _tracker.createInstance<sql_parserParser::StatementDefaultContext>(_localctx);
    enterOuterAlt(_localctx, 1);
    setState(152);
    query();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommentSpecContext ------------------------------------------------------------------

sql_parserParser::CommentSpecContext::CommentSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* sql_parserParser::CommentSpecContext::COMMENT() {
  return getToken(sql_parserParser::COMMENT, 0);
}

tree::TerminalNode* sql_parserParser::CommentSpecContext::STRING() {
  return getToken(sql_parserParser::STRING, 0);
}


size_t sql_parserParser::CommentSpecContext::getRuleIndex() const {
  return sql_parserParser::RuleCommentSpec;
}


std::any sql_parserParser::CommentSpecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitCommentSpec(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::CommentSpecContext* sql_parserParser::commentSpec() {
  CommentSpecContext *_localctx = _tracker.createInstance<CommentSpecContext>(_ctx, getState());
  enterRule(_localctx, 6, sql_parserParser::RuleCommentSpec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(154);
    match(sql_parserParser::COMMENT);
    setState(155);
    match(sql_parserParser::STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryContext ------------------------------------------------------------------

sql_parserParser::QueryContext::QueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

sql_parserParser::QueryTermContext* sql_parserParser::QueryContext::queryTerm() {
  return getRuleContext<sql_parserParser::QueryTermContext>(0);
}

sql_parserParser::QueryOrganizationContext* sql_parserParser::QueryContext::queryOrganization() {
  return getRuleContext<sql_parserParser::QueryOrganizationContext>(0);
}


size_t sql_parserParser::QueryContext::getRuleIndex() const {
  return sql_parserParser::RuleQuery;
}


std::any sql_parserParser::QueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitQuery(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::QueryContext* sql_parserParser::query() {
  QueryContext *_localctx = _tracker.createInstance<QueryContext>(_ctx, getState());
  enterRule(_localctx, 8, sql_parserParser::RuleQuery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(157);
    queryTerm();
    setState(158);
    queryOrganization();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryOrganizationContext ------------------------------------------------------------------

sql_parserParser::QueryOrganizationContext::QueryOrganizationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* sql_parserParser::QueryOrganizationContext::ORDER() {
  return getToken(sql_parserParser::ORDER, 0);
}

std::vector<tree::TerminalNode *> sql_parserParser::QueryOrganizationContext::BY() {
  return getTokens(sql_parserParser::BY);
}

tree::TerminalNode* sql_parserParser::QueryOrganizationContext::BY(size_t i) {
  return getToken(sql_parserParser::BY, i);
}

tree::TerminalNode* sql_parserParser::QueryOrganizationContext::SORT() {
  return getToken(sql_parserParser::SORT, 0);
}

tree::TerminalNode* sql_parserParser::QueryOrganizationContext::LIMIT() {
  return getToken(sql_parserParser::LIMIT, 0);
}

std::vector<sql_parserParser::SortItemContext *> sql_parserParser::QueryOrganizationContext::sortItem() {
  return getRuleContexts<sql_parserParser::SortItemContext>();
}

sql_parserParser::SortItemContext* sql_parserParser::QueryOrganizationContext::sortItem(size_t i) {
  return getRuleContext<sql_parserParser::SortItemContext>(i);
}

tree::TerminalNode* sql_parserParser::QueryOrganizationContext::ALL() {
  return getToken(sql_parserParser::ALL, 0);
}

sql_parserParser::ExpressionContext* sql_parserParser::QueryOrganizationContext::expression() {
  return getRuleContext<sql_parserParser::ExpressionContext>(0);
}


size_t sql_parserParser::QueryOrganizationContext::getRuleIndex() const {
  return sql_parserParser::RuleQueryOrganization;
}


std::any sql_parserParser::QueryOrganizationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitQueryOrganization(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::QueryOrganizationContext* sql_parserParser::queryOrganization() {
  QueryOrganizationContext *_localctx = _tracker.createInstance<QueryOrganizationContext>(_ctx, getState());
  enterRule(_localctx, 10, sql_parserParser::RuleQueryOrganization);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(170);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == sql_parserParser::ORDER) {
      setState(160);
      match(sql_parserParser::ORDER);
      setState(161);
      match(sql_parserParser::BY);
      setState(162);
      antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->sortItemContext = sortItem();
      antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->order.push_back(antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->sortItemContext);
      setState(167);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == sql_parserParser::T__1) {
        setState(163);
        match(sql_parserParser::T__1);
        setState(164);
        antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->sortItemContext = sortItem();
        antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->order.push_back(antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->sortItemContext);
        setState(169);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(182);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == sql_parserParser::SORT) {
      setState(172);
      match(sql_parserParser::SORT);
      setState(173);
      match(sql_parserParser::BY);
      setState(174);
      antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->sortItemContext = sortItem();
      antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->sort.push_back(antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->sortItemContext);
      setState(179);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == sql_parserParser::T__1) {
        setState(175);
        match(sql_parserParser::T__1);
        setState(176);
        antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->sortItemContext = sortItem();
        antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->sort.push_back(antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->sortItemContext);
        setState(181);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(189);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == sql_parserParser::LIMIT) {
      setState(184);
      match(sql_parserParser::LIMIT);
      setState(187);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx)) {
      case 1: {
        setState(185);
        match(sql_parserParser::ALL);
        break;
      }

      case 2: {
        setState(186);
        antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->limit = expression();
        break;
      }

      default:
        break;
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryTermContext ------------------------------------------------------------------

sql_parserParser::QueryTermContext::QueryTermContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t sql_parserParser::QueryTermContext::getRuleIndex() const {
  return sql_parserParser::RuleQueryTerm;
}

void sql_parserParser::QueryTermContext::copyFrom(QueryTermContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- QueryTermDefaultContext ------------------------------------------------------------------

sql_parserParser::QueryPrimaryContext* sql_parserParser::QueryTermDefaultContext::queryPrimary() {
  return getRuleContext<sql_parserParser::QueryPrimaryContext>(0);
}

sql_parserParser::QueryTermDefaultContext::QueryTermDefaultContext(QueryTermContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::QueryTermDefaultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitQueryTermDefault(this);
  else
    return visitor->visitChildren(this);
}
sql_parserParser::QueryTermContext* sql_parserParser::queryTerm() {
  QueryTermContext *_localctx = _tracker.createInstance<QueryTermContext>(_ctx, getState());
  enterRule(_localctx, 12, sql_parserParser::RuleQueryTerm);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    _localctx = _tracker.createInstance<sql_parserParser::QueryTermDefaultContext>(_localctx);
    enterOuterAlt(_localctx, 1);
    setState(191);
    queryPrimary();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryPrimaryContext ------------------------------------------------------------------

sql_parserParser::QueryPrimaryContext::QueryPrimaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t sql_parserParser::QueryPrimaryContext::getRuleIndex() const {
  return sql_parserParser::RuleQueryPrimary;
}

void sql_parserParser::QueryPrimaryContext::copyFrom(QueryPrimaryContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- SubqueryContext ------------------------------------------------------------------

sql_parserParser::QueryContext* sql_parserParser::SubqueryContext::query() {
  return getRuleContext<sql_parserParser::QueryContext>(0);
}

sql_parserParser::SubqueryContext::SubqueryContext(QueryPrimaryContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::SubqueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitSubquery(this);
  else
    return visitor->visitChildren(this);
}
//----------------- QueryPrimaryDefaultContext ------------------------------------------------------------------

sql_parserParser::QuerySpecificationContext* sql_parserParser::QueryPrimaryDefaultContext::querySpecification() {
  return getRuleContext<sql_parserParser::QuerySpecificationContext>(0);
}

sql_parserParser::QueryPrimaryDefaultContext::QueryPrimaryDefaultContext(QueryPrimaryContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::QueryPrimaryDefaultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitQueryPrimaryDefault(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableContext ------------------------------------------------------------------

tree::TerminalNode* sql_parserParser::TableContext::TABLE() {
  return getToken(sql_parserParser::TABLE, 0);
}

sql_parserParser::MultipartIdentifierContext* sql_parserParser::TableContext::multipartIdentifier() {
  return getRuleContext<sql_parserParser::MultipartIdentifierContext>(0);
}

sql_parserParser::TableContext::TableContext(QueryPrimaryContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::TableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitTable(this);
  else
    return visitor->visitChildren(this);
}
sql_parserParser::QueryPrimaryContext* sql_parserParser::queryPrimary() {
  QueryPrimaryContext *_localctx = _tracker.createInstance<QueryPrimaryContext>(_ctx, getState());
  enterRule(_localctx, 14, sql_parserParser::RuleQueryPrimary);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(200);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case sql_parserParser::SELECT: {
        _localctx = _tracker.createInstance<sql_parserParser::QueryPrimaryDefaultContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(193);
        querySpecification();
        break;
      }

      case sql_parserParser::TABLE: {
        _localctx = _tracker.createInstance<sql_parserParser::TableContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(194);
        match(sql_parserParser::TABLE);
        setState(195);
        multipartIdentifier();
        break;
      }

      case sql_parserParser::T__2: {
        _localctx = _tracker.createInstance<sql_parserParser::SubqueryContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(196);
        match(sql_parserParser::T__2);
        setState(197);
        query();
        setState(198);
        match(sql_parserParser::T__3);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SortItemContext ------------------------------------------------------------------

sql_parserParser::SortItemContext::SortItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

sql_parserParser::ExpressionContext* sql_parserParser::SortItemContext::expression() {
  return getRuleContext<sql_parserParser::ExpressionContext>(0);
}

tree::TerminalNode* sql_parserParser::SortItemContext::NULLS() {
  return getToken(sql_parserParser::NULLS, 0);
}

tree::TerminalNode* sql_parserParser::SortItemContext::ASC() {
  return getToken(sql_parserParser::ASC, 0);
}

tree::TerminalNode* sql_parserParser::SortItemContext::DESC() {
  return getToken(sql_parserParser::DESC, 0);
}

tree::TerminalNode* sql_parserParser::SortItemContext::LAST() {
  return getToken(sql_parserParser::LAST, 0);
}

tree::TerminalNode* sql_parserParser::SortItemContext::FIRST() {
  return getToken(sql_parserParser::FIRST, 0);
}


size_t sql_parserParser::SortItemContext::getRuleIndex() const {
  return sql_parserParser::RuleSortItem;
}


std::any sql_parserParser::SortItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitSortItem(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::SortItemContext* sql_parserParser::sortItem() {
  SortItemContext *_localctx = _tracker.createInstance<SortItemContext>(_ctx, getState());
  enterRule(_localctx, 16, sql_parserParser::RuleSortItem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(202);
    expression();
    setState(204);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == sql_parserParser::ASC

    || _la == sql_parserParser::DESC) {
      setState(203);
      antlrcpp::downCast<SortItemContext *>(_localctx)->ordering = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == sql_parserParser::ASC

      || _la == sql_parserParser::DESC)) {
        antlrcpp::downCast<SortItemContext *>(_localctx)->ordering = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(208);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == sql_parserParser::NULLS) {
      setState(206);
      match(sql_parserParser::NULLS);
      setState(207);
      antlrcpp::downCast<SortItemContext *>(_localctx)->nullOrder = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == sql_parserParser::FIRST

      || _la == sql_parserParser::LAST)) {
        antlrcpp::downCast<SortItemContext *>(_localctx)->nullOrder = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QuerySpecificationContext ------------------------------------------------------------------

sql_parserParser::QuerySpecificationContext::QuerySpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

sql_parserParser::SelectClauseContext* sql_parserParser::QuerySpecificationContext::selectClause() {
  return getRuleContext<sql_parserParser::SelectClauseContext>(0);
}

sql_parserParser::FromClauseContext* sql_parserParser::QuerySpecificationContext::fromClause() {
  return getRuleContext<sql_parserParser::FromClauseContext>(0);
}

sql_parserParser::WhereClauseContext* sql_parserParser::QuerySpecificationContext::whereClause() {
  return getRuleContext<sql_parserParser::WhereClauseContext>(0);
}


size_t sql_parserParser::QuerySpecificationContext::getRuleIndex() const {
  return sql_parserParser::RuleQuerySpecification;
}


std::any sql_parserParser::QuerySpecificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitQuerySpecification(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::QuerySpecificationContext* sql_parserParser::querySpecification() {
  QuerySpecificationContext *_localctx = _tracker.createInstance<QuerySpecificationContext>(_ctx, getState());
  enterRule(_localctx, 18, sql_parserParser::RuleQuerySpecification);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(210);
    selectClause();
    setState(212);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == sql_parserParser::FROM) {
      setState(211);
      fromClause();
    }
    setState(215);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == sql_parserParser::WHERE) {
      setState(214);
      whereClause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectClauseContext ------------------------------------------------------------------

sql_parserParser::SelectClauseContext::SelectClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* sql_parserParser::SelectClauseContext::SELECT() {
  return getToken(sql_parserParser::SELECT, 0);
}

sql_parserParser::NamedExpressionSeqContext* sql_parserParser::SelectClauseContext::namedExpressionSeq() {
  return getRuleContext<sql_parserParser::NamedExpressionSeqContext>(0);
}

sql_parserParser::SetQuantifierContext* sql_parserParser::SelectClauseContext::setQuantifier() {
  return getRuleContext<sql_parserParser::SetQuantifierContext>(0);
}


size_t sql_parserParser::SelectClauseContext::getRuleIndex() const {
  return sql_parserParser::RuleSelectClause;
}


std::any sql_parserParser::SelectClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitSelectClause(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::SelectClauseContext* sql_parserParser::selectClause() {
  SelectClauseContext *_localctx = _tracker.createInstance<SelectClauseContext>(_ctx, getState());
  enterRule(_localctx, 20, sql_parserParser::RuleSelectClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(217);
    match(sql_parserParser::SELECT);
    setState(219);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx)) {
    case 1: {
      setState(218);
      setQuantifier();
      break;
    }

    default:
      break;
    }
    setState(221);
    namedExpressionSeq();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhereClauseContext ------------------------------------------------------------------

sql_parserParser::WhereClauseContext::WhereClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* sql_parserParser::WhereClauseContext::WHERE() {
  return getToken(sql_parserParser::WHERE, 0);
}

sql_parserParser::BooleanExpressionContext* sql_parserParser::WhereClauseContext::booleanExpression() {
  return getRuleContext<sql_parserParser::BooleanExpressionContext>(0);
}


size_t sql_parserParser::WhereClauseContext::getRuleIndex() const {
  return sql_parserParser::RuleWhereClause;
}


std::any sql_parserParser::WhereClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitWhereClause(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::WhereClauseContext* sql_parserParser::whereClause() {
  WhereClauseContext *_localctx = _tracker.createInstance<WhereClauseContext>(_ctx, getState());
  enterRule(_localctx, 22, sql_parserParser::RuleWhereClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(223);
    match(sql_parserParser::WHERE);
    setState(224);
    booleanExpression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FromClauseContext ------------------------------------------------------------------

sql_parserParser::FromClauseContext::FromClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* sql_parserParser::FromClauseContext::FROM() {
  return getToken(sql_parserParser::FROM, 0);
}

std::vector<sql_parserParser::RelationContext *> sql_parserParser::FromClauseContext::relation() {
  return getRuleContexts<sql_parserParser::RelationContext>();
}

sql_parserParser::RelationContext* sql_parserParser::FromClauseContext::relation(size_t i) {
  return getRuleContext<sql_parserParser::RelationContext>(i);
}


size_t sql_parserParser::FromClauseContext::getRuleIndex() const {
  return sql_parserParser::RuleFromClause;
}


std::any sql_parserParser::FromClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitFromClause(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::FromClauseContext* sql_parserParser::fromClause() {
  FromClauseContext *_localctx = _tracker.createInstance<FromClauseContext>(_ctx, getState());
  enterRule(_localctx, 24, sql_parserParser::RuleFromClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(226);
    match(sql_parserParser::FROM);
    setState(227);
    relation();
    setState(232);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == sql_parserParser::T__1) {
      setState(228);
      match(sql_parserParser::T__1);
      setState(229);
      relation();
      setState(234);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetQuantifierContext ------------------------------------------------------------------

sql_parserParser::SetQuantifierContext::SetQuantifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* sql_parserParser::SetQuantifierContext::DISTINCT() {
  return getToken(sql_parserParser::DISTINCT, 0);
}

tree::TerminalNode* sql_parserParser::SetQuantifierContext::ALL() {
  return getToken(sql_parserParser::ALL, 0);
}


size_t sql_parserParser::SetQuantifierContext::getRuleIndex() const {
  return sql_parserParser::RuleSetQuantifier;
}


std::any sql_parserParser::SetQuantifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitSetQuantifier(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::SetQuantifierContext* sql_parserParser::setQuantifier() {
  SetQuantifierContext *_localctx = _tracker.createInstance<SetQuantifierContext>(_ctx, getState());
  enterRule(_localctx, 26, sql_parserParser::RuleSetQuantifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(235);
    _la = _input->LA(1);
    if (!(_la == sql_parserParser::ALL

    || _la == sql_parserParser::DISTINCT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelationContext ------------------------------------------------------------------

sql_parserParser::RelationContext::RelationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

sql_parserParser::RelationPrimaryContext* sql_parserParser::RelationContext::relationPrimary() {
  return getRuleContext<sql_parserParser::RelationPrimaryContext>(0);
}


size_t sql_parserParser::RelationContext::getRuleIndex() const {
  return sql_parserParser::RuleRelation;
}


std::any sql_parserParser::RelationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitRelation(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::RelationContext* sql_parserParser::relation() {
  RelationContext *_localctx = _tracker.createInstance<RelationContext>(_ctx, getState());
  enterRule(_localctx, 28, sql_parserParser::RuleRelation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(237);
    relationPrimary();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierListContext ------------------------------------------------------------------

sql_parserParser::IdentifierListContext::IdentifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

sql_parserParser::IdentifierSeqContext* sql_parserParser::IdentifierListContext::identifierSeq() {
  return getRuleContext<sql_parserParser::IdentifierSeqContext>(0);
}


size_t sql_parserParser::IdentifierListContext::getRuleIndex() const {
  return sql_parserParser::RuleIdentifierList;
}


std::any sql_parserParser::IdentifierListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitIdentifierList(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::IdentifierListContext* sql_parserParser::identifierList() {
  IdentifierListContext *_localctx = _tracker.createInstance<IdentifierListContext>(_ctx, getState());
  enterRule(_localctx, 30, sql_parserParser::RuleIdentifierList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(239);
    match(sql_parserParser::T__2);
    setState(240);
    identifierSeq();
    setState(241);
    match(sql_parserParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierSeqContext ------------------------------------------------------------------

sql_parserParser::IdentifierSeqContext::IdentifierSeqContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<sql_parserParser::ErrorCapturingIdentifierContext *> sql_parserParser::IdentifierSeqContext::errorCapturingIdentifier() {
  return getRuleContexts<sql_parserParser::ErrorCapturingIdentifierContext>();
}

sql_parserParser::ErrorCapturingIdentifierContext* sql_parserParser::IdentifierSeqContext::errorCapturingIdentifier(size_t i) {
  return getRuleContext<sql_parserParser::ErrorCapturingIdentifierContext>(i);
}


size_t sql_parserParser::IdentifierSeqContext::getRuleIndex() const {
  return sql_parserParser::RuleIdentifierSeq;
}


std::any sql_parserParser::IdentifierSeqContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitIdentifierSeq(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::IdentifierSeqContext* sql_parserParser::identifierSeq() {
  IdentifierSeqContext *_localctx = _tracker.createInstance<IdentifierSeqContext>(_ctx, getState());
  enterRule(_localctx, 32, sql_parserParser::RuleIdentifierSeq);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(243);
    antlrcpp::downCast<IdentifierSeqContext *>(_localctx)->errorCapturingIdentifierContext = errorCapturingIdentifier();
    antlrcpp::downCast<IdentifierSeqContext *>(_localctx)->ident.push_back(antlrcpp::downCast<IdentifierSeqContext *>(_localctx)->errorCapturingIdentifierContext);
    setState(248);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == sql_parserParser::T__1) {
      setState(244);
      match(sql_parserParser::T__1);
      setState(245);
      antlrcpp::downCast<IdentifierSeqContext *>(_localctx)->errorCapturingIdentifierContext = errorCapturingIdentifier();
      antlrcpp::downCast<IdentifierSeqContext *>(_localctx)->ident.push_back(antlrcpp::downCast<IdentifierSeqContext *>(_localctx)->errorCapturingIdentifierContext);
      setState(250);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OrderedIdentifierListContext ------------------------------------------------------------------

sql_parserParser::OrderedIdentifierListContext::OrderedIdentifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<sql_parserParser::OrderedIdentifierContext *> sql_parserParser::OrderedIdentifierListContext::orderedIdentifier() {
  return getRuleContexts<sql_parserParser::OrderedIdentifierContext>();
}

sql_parserParser::OrderedIdentifierContext* sql_parserParser::OrderedIdentifierListContext::orderedIdentifier(size_t i) {
  return getRuleContext<sql_parserParser::OrderedIdentifierContext>(i);
}


size_t sql_parserParser::OrderedIdentifierListContext::getRuleIndex() const {
  return sql_parserParser::RuleOrderedIdentifierList;
}


std::any sql_parserParser::OrderedIdentifierListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitOrderedIdentifierList(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::OrderedIdentifierListContext* sql_parserParser::orderedIdentifierList() {
  OrderedIdentifierListContext *_localctx = _tracker.createInstance<OrderedIdentifierListContext>(_ctx, getState());
  enterRule(_localctx, 34, sql_parserParser::RuleOrderedIdentifierList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(251);
    match(sql_parserParser::T__2);
    setState(252);
    orderedIdentifier();
    setState(257);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == sql_parserParser::T__1) {
      setState(253);
      match(sql_parserParser::T__1);
      setState(254);
      orderedIdentifier();
      setState(259);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(260);
    match(sql_parserParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OrderedIdentifierContext ------------------------------------------------------------------

sql_parserParser::OrderedIdentifierContext::OrderedIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

sql_parserParser::ErrorCapturingIdentifierContext* sql_parserParser::OrderedIdentifierContext::errorCapturingIdentifier() {
  return getRuleContext<sql_parserParser::ErrorCapturingIdentifierContext>(0);
}

tree::TerminalNode* sql_parserParser::OrderedIdentifierContext::ASC() {
  return getToken(sql_parserParser::ASC, 0);
}

tree::TerminalNode* sql_parserParser::OrderedIdentifierContext::DESC() {
  return getToken(sql_parserParser::DESC, 0);
}


size_t sql_parserParser::OrderedIdentifierContext::getRuleIndex() const {
  return sql_parserParser::RuleOrderedIdentifier;
}


std::any sql_parserParser::OrderedIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitOrderedIdentifier(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::OrderedIdentifierContext* sql_parserParser::orderedIdentifier() {
  OrderedIdentifierContext *_localctx = _tracker.createInstance<OrderedIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 36, sql_parserParser::RuleOrderedIdentifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(262);
    antlrcpp::downCast<OrderedIdentifierContext *>(_localctx)->ident = errorCapturingIdentifier();
    setState(264);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == sql_parserParser::ASC

    || _la == sql_parserParser::DESC) {
      setState(263);
      antlrcpp::downCast<OrderedIdentifierContext *>(_localctx)->ordering = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == sql_parserParser::ASC

      || _la == sql_parserParser::DESC)) {
        antlrcpp::downCast<OrderedIdentifierContext *>(_localctx)->ordering = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierCommentListContext ------------------------------------------------------------------

sql_parserParser::IdentifierCommentListContext::IdentifierCommentListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<sql_parserParser::IdentifierCommentContext *> sql_parserParser::IdentifierCommentListContext::identifierComment() {
  return getRuleContexts<sql_parserParser::IdentifierCommentContext>();
}

sql_parserParser::IdentifierCommentContext* sql_parserParser::IdentifierCommentListContext::identifierComment(size_t i) {
  return getRuleContext<sql_parserParser::IdentifierCommentContext>(i);
}


size_t sql_parserParser::IdentifierCommentListContext::getRuleIndex() const {
  return sql_parserParser::RuleIdentifierCommentList;
}


std::any sql_parserParser::IdentifierCommentListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitIdentifierCommentList(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::IdentifierCommentListContext* sql_parserParser::identifierCommentList() {
  IdentifierCommentListContext *_localctx = _tracker.createInstance<IdentifierCommentListContext>(_ctx, getState());
  enterRule(_localctx, 38, sql_parserParser::RuleIdentifierCommentList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(266);
    match(sql_parserParser::T__2);
    setState(267);
    identifierComment();
    setState(272);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == sql_parserParser::T__1) {
      setState(268);
      match(sql_parserParser::T__1);
      setState(269);
      identifierComment();
      setState(274);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(275);
    match(sql_parserParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierCommentContext ------------------------------------------------------------------

sql_parserParser::IdentifierCommentContext::IdentifierCommentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

sql_parserParser::IdentifierContext* sql_parserParser::IdentifierCommentContext::identifier() {
  return getRuleContext<sql_parserParser::IdentifierContext>(0);
}

sql_parserParser::CommentSpecContext* sql_parserParser::IdentifierCommentContext::commentSpec() {
  return getRuleContext<sql_parserParser::CommentSpecContext>(0);
}


size_t sql_parserParser::IdentifierCommentContext::getRuleIndex() const {
  return sql_parserParser::RuleIdentifierComment;
}


std::any sql_parserParser::IdentifierCommentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitIdentifierComment(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::IdentifierCommentContext* sql_parserParser::identifierComment() {
  IdentifierCommentContext *_localctx = _tracker.createInstance<IdentifierCommentContext>(_ctx, getState());
  enterRule(_localctx, 40, sql_parserParser::RuleIdentifierComment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(277);
    identifier();
    setState(279);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == sql_parserParser::COMMENT) {
      setState(278);
      commentSpec();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelationPrimaryContext ------------------------------------------------------------------

sql_parserParser::RelationPrimaryContext::RelationPrimaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t sql_parserParser::RelationPrimaryContext::getRuleIndex() const {
  return sql_parserParser::RuleRelationPrimary;
}

void sql_parserParser::RelationPrimaryContext::copyFrom(RelationPrimaryContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- AliasedRelationContext ------------------------------------------------------------------

sql_parserParser::RelationContext* sql_parserParser::AliasedRelationContext::relation() {
  return getRuleContext<sql_parserParser::RelationContext>(0);
}

sql_parserParser::TableAliasContext* sql_parserParser::AliasedRelationContext::tableAlias() {
  return getRuleContext<sql_parserParser::TableAliasContext>(0);
}

sql_parserParser::AliasedRelationContext::AliasedRelationContext(RelationPrimaryContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::AliasedRelationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitAliasedRelation(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AliasedQueryContext ------------------------------------------------------------------

sql_parserParser::QueryContext* sql_parserParser::AliasedQueryContext::query() {
  return getRuleContext<sql_parserParser::QueryContext>(0);
}

sql_parserParser::TableAliasContext* sql_parserParser::AliasedQueryContext::tableAlias() {
  return getRuleContext<sql_parserParser::TableAliasContext>(0);
}

sql_parserParser::AliasedQueryContext::AliasedQueryContext(RelationPrimaryContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::AliasedQueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitAliasedQuery(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableNameContext ------------------------------------------------------------------

sql_parserParser::MultipartIdentifierContext* sql_parserParser::TableNameContext::multipartIdentifier() {
  return getRuleContext<sql_parserParser::MultipartIdentifierContext>(0);
}

sql_parserParser::TableAliasContext* sql_parserParser::TableNameContext::tableAlias() {
  return getRuleContext<sql_parserParser::TableAliasContext>(0);
}

sql_parserParser::TableNameContext::TableNameContext(RelationPrimaryContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::TableNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitTableName(this);
  else
    return visitor->visitChildren(this);
}
sql_parserParser::RelationPrimaryContext* sql_parserParser::relationPrimary() {
  RelationPrimaryContext *_localctx = _tracker.createInstance<RelationPrimaryContext>(_ctx, getState());
  enterRule(_localctx, 42, sql_parserParser::RuleRelationPrimary);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(294);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<sql_parserParser::TableNameContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(281);
      multipartIdentifier();
      setState(282);
      tableAlias();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<sql_parserParser::AliasedQueryContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(284);
      match(sql_parserParser::T__2);
      setState(285);
      query();
      setState(286);
      match(sql_parserParser::T__3);
      setState(287);
      tableAlias();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<sql_parserParser::AliasedRelationContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(289);
      match(sql_parserParser::T__2);
      setState(290);
      relation();
      setState(291);
      match(sql_parserParser::T__3);
      setState(292);
      tableAlias();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableAliasContext ------------------------------------------------------------------

sql_parserParser::TableAliasContext::TableAliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

sql_parserParser::StrictIdentifierContext* sql_parserParser::TableAliasContext::strictIdentifier() {
  return getRuleContext<sql_parserParser::StrictIdentifierContext>(0);
}

tree::TerminalNode* sql_parserParser::TableAliasContext::AS() {
  return getToken(sql_parserParser::AS, 0);
}

sql_parserParser::IdentifierListContext* sql_parserParser::TableAliasContext::identifierList() {
  return getRuleContext<sql_parserParser::IdentifierListContext>(0);
}


size_t sql_parserParser::TableAliasContext::getRuleIndex() const {
  return sql_parserParser::RuleTableAlias;
}


std::any sql_parserParser::TableAliasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitTableAlias(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::TableAliasContext* sql_parserParser::tableAlias() {
  TableAliasContext *_localctx = _tracker.createInstance<TableAliasContext>(_ctx, getState());
  enterRule(_localctx, 44, sql_parserParser::RuleTableAlias);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(303);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx)) {
    case 1: {
      setState(297);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx)) {
      case 1: {
        setState(296);
        match(sql_parserParser::AS);
        break;
      }

      default:
        break;
      }
      setState(299);
      strictIdentifier();
      setState(301);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == sql_parserParser::T__2) {
        setState(300);
        identifierList();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultipartIdentifierListContext ------------------------------------------------------------------

sql_parserParser::MultipartIdentifierListContext::MultipartIdentifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<sql_parserParser::MultipartIdentifierContext *> sql_parserParser::MultipartIdentifierListContext::multipartIdentifier() {
  return getRuleContexts<sql_parserParser::MultipartIdentifierContext>();
}

sql_parserParser::MultipartIdentifierContext* sql_parserParser::MultipartIdentifierListContext::multipartIdentifier(size_t i) {
  return getRuleContext<sql_parserParser::MultipartIdentifierContext>(i);
}


size_t sql_parserParser::MultipartIdentifierListContext::getRuleIndex() const {
  return sql_parserParser::RuleMultipartIdentifierList;
}


std::any sql_parserParser::MultipartIdentifierListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitMultipartIdentifierList(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::MultipartIdentifierListContext* sql_parserParser::multipartIdentifierList() {
  MultipartIdentifierListContext *_localctx = _tracker.createInstance<MultipartIdentifierListContext>(_ctx, getState());
  enterRule(_localctx, 46, sql_parserParser::RuleMultipartIdentifierList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(305);
    multipartIdentifier();
    setState(310);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == sql_parserParser::T__1) {
      setState(306);
      match(sql_parserParser::T__1);
      setState(307);
      multipartIdentifier();
      setState(312);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultipartIdentifierContext ------------------------------------------------------------------

sql_parserParser::MultipartIdentifierContext::MultipartIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<sql_parserParser::ErrorCapturingIdentifierContext *> sql_parserParser::MultipartIdentifierContext::errorCapturingIdentifier() {
  return getRuleContexts<sql_parserParser::ErrorCapturingIdentifierContext>();
}

sql_parserParser::ErrorCapturingIdentifierContext* sql_parserParser::MultipartIdentifierContext::errorCapturingIdentifier(size_t i) {
  return getRuleContext<sql_parserParser::ErrorCapturingIdentifierContext>(i);
}


size_t sql_parserParser::MultipartIdentifierContext::getRuleIndex() const {
  return sql_parserParser::RuleMultipartIdentifier;
}


std::any sql_parserParser::MultipartIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitMultipartIdentifier(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::MultipartIdentifierContext* sql_parserParser::multipartIdentifier() {
  MultipartIdentifierContext *_localctx = _tracker.createInstance<MultipartIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 48, sql_parserParser::RuleMultipartIdentifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(313);
    antlrcpp::downCast<MultipartIdentifierContext *>(_localctx)->errorCapturingIdentifierContext = errorCapturingIdentifier();
    antlrcpp::downCast<MultipartIdentifierContext *>(_localctx)->parts.push_back(antlrcpp::downCast<MultipartIdentifierContext *>(_localctx)->errorCapturingIdentifierContext);
    setState(318);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == sql_parserParser::T__4) {
      setState(314);
      match(sql_parserParser::T__4);
      setState(315);
      antlrcpp::downCast<MultipartIdentifierContext *>(_localctx)->errorCapturingIdentifierContext = errorCapturingIdentifier();
      antlrcpp::downCast<MultipartIdentifierContext *>(_localctx)->parts.push_back(antlrcpp::downCast<MultipartIdentifierContext *>(_localctx)->errorCapturingIdentifierContext);
      setState(320);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamedExpressionContext ------------------------------------------------------------------

sql_parserParser::NamedExpressionContext::NamedExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

sql_parserParser::ExpressionContext* sql_parserParser::NamedExpressionContext::expression() {
  return getRuleContext<sql_parserParser::ExpressionContext>(0);
}

sql_parserParser::IdentifierListContext* sql_parserParser::NamedExpressionContext::identifierList() {
  return getRuleContext<sql_parserParser::IdentifierListContext>(0);
}

tree::TerminalNode* sql_parserParser::NamedExpressionContext::AS() {
  return getToken(sql_parserParser::AS, 0);
}

sql_parserParser::ErrorCapturingIdentifierContext* sql_parserParser::NamedExpressionContext::errorCapturingIdentifier() {
  return getRuleContext<sql_parserParser::ErrorCapturingIdentifierContext>(0);
}


size_t sql_parserParser::NamedExpressionContext::getRuleIndex() const {
  return sql_parserParser::RuleNamedExpression;
}


std::any sql_parserParser::NamedExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitNamedExpression(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::NamedExpressionContext* sql_parserParser::namedExpression() {
  NamedExpressionContext *_localctx = _tracker.createInstance<NamedExpressionContext>(_ctx, getState());
  enterRule(_localctx, 50, sql_parserParser::RuleNamedExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(321);
    expression();
    setState(329);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
    case 1: {
      setState(323);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx)) {
      case 1: {
        setState(322);
        match(sql_parserParser::AS);
        break;
      }

      default:
        break;
      }
      setState(327);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case sql_parserParser::ADD:
        case sql_parserParser::AFTER:
        case sql_parserParser::ALL:
        case sql_parserParser::ALTER:
        case sql_parserParser::ANALYZE:
        case sql_parserParser::AND:
        case sql_parserParser::ANTI:
        case sql_parserParser::ANY:
        case sql_parserParser::ARCHIVE:
        case sql_parserParser::ARRAY:
        case sql_parserParser::AS:
        case sql_parserParser::ASC:
        case sql_parserParser::AT:
        case sql_parserParser::AUTHORIZATION:
        case sql_parserParser::BETWEEN:
        case sql_parserParser::BOTH:
        case sql_parserParser::BUCKET:
        case sql_parserParser::BUCKETS:
        case sql_parserParser::BY:
        case sql_parserParser::CACHE:
        case sql_parserParser::CASCADE:
        case sql_parserParser::CASE:
        case sql_parserParser::CAST:
        case sql_parserParser::CHANGE:
        case sql_parserParser::CHECK:
        case sql_parserParser::CLEAR:
        case sql_parserParser::CLUSTER:
        case sql_parserParser::CLUSTERED:
        case sql_parserParser::CODEGEN:
        case sql_parserParser::COLLATE:
        case sql_parserParser::COLLECTION:
        case sql_parserParser::COLUMN:
        case sql_parserParser::COLUMNS:
        case sql_parserParser::COMMENT:
        case sql_parserParser::COMMIT:
        case sql_parserParser::COMPACT:
        case sql_parserParser::COMPACTIONS:
        case sql_parserParser::COMPUTE:
        case sql_parserParser::CONCATENATE:
        case sql_parserParser::CONSTRAINT:
        case sql_parserParser::COST:
        case sql_parserParser::CREATE:
        case sql_parserParser::CROSS:
        case sql_parserParser::CUBE:
        case sql_parserParser::CURRENT:
        case sql_parserParser::CURRENT_DATE:
        case sql_parserParser::CURRENT_TIME:
        case sql_parserParser::CURRENT_TIMESTAMP:
        case sql_parserParser::CURRENT_USER:
        case sql_parserParser::DATA:
        case sql_parserParser::DATABASE:
        case sql_parserParser::DATABASES:
        case sql_parserParser::DBPROPERTIES:
        case sql_parserParser::DEFINED:
        case sql_parserParser::DELETE:
        case sql_parserParser::DELIMITED:
        case sql_parserParser::DESC:
        case sql_parserParser::DESCRIBE:
        case sql_parserParser::DFS:
        case sql_parserParser::DIRECTORIES:
        case sql_parserParser::DIRECTORY:
        case sql_parserParser::DISTINCT:
        case sql_parserParser::DISTRIBUTE:
        case sql_parserParser::DIV:
        case sql_parserParser::DROP:
        case sql_parserParser::ELSE:
        case sql_parserParser::END:
        case sql_parserParser::ESCAPE:
        case sql_parserParser::ESCAPED:
        case sql_parserParser::EXCEPT:
        case sql_parserParser::EXCHANGE:
        case sql_parserParser::EXISTS:
        case sql_parserParser::EXPLAIN:
        case sql_parserParser::EXPORT:
        case sql_parserParser::EXTENDED:
        case sql_parserParser::EXTERNAL:
        case sql_parserParser::EXTRACT:
        case sql_parserParser::FALSE:
        case sql_parserParser::FETCH:
        case sql_parserParser::FIELDS:
        case sql_parserParser::FILTER:
        case sql_parserParser::FILEFORMAT:
        case sql_parserParser::FIRST:
        case sql_parserParser::FOLLOWING:
        case sql_parserParser::FOR:
        case sql_parserParser::FOREIGN:
        case sql_parserParser::FORMAT:
        case sql_parserParser::FORMATTED:
        case sql_parserParser::FROM:
        case sql_parserParser::FULL:
        case sql_parserParser::FUNCTION:
        case sql_parserParser::FUNCTIONS:
        case sql_parserParser::GLOBAL:
        case sql_parserParser::GRANT:
        case sql_parserParser::GROUP:
        case sql_parserParser::GROUPING:
        case sql_parserParser::HAVING:
        case sql_parserParser::IF:
        case sql_parserParser::IGNORE:
        case sql_parserParser::IMPORT:
        case sql_parserParser::IN:
        case sql_parserParser::INDEX:
        case sql_parserParser::INDEXES:
        case sql_parserParser::INNER:
        case sql_parserParser::INPATH:
        case sql_parserParser::INPUTFORMAT:
        case sql_parserParser::INSERT:
        case sql_parserParser::INTERSECT:
        case sql_parserParser::INTERVAL:
        case sql_parserParser::INTO:
        case sql_parserParser::IS:
        case sql_parserParser::ITEMS:
        case sql_parserParser::JOIN:
        case sql_parserParser::KEYS:
        case sql_parserParser::LAST:
        case sql_parserParser::LATERAL:
        case sql_parserParser::LAZY:
        case sql_parserParser::LEADING:
        case sql_parserParser::LEFT:
        case sql_parserParser::LIKE:
        case sql_parserParser::LIMIT:
        case sql_parserParser::LINES:
        case sql_parserParser::LIST:
        case sql_parserParser::LOAD:
        case sql_parserParser::LOCAL:
        case sql_parserParser::LOCATION:
        case sql_parserParser::LOCK:
        case sql_parserParser::LOCKS:
        case sql_parserParser::LOGICAL:
        case sql_parserParser::MACRO:
        case sql_parserParser::MAP:
        case sql_parserParser::MATCHED:
        case sql_parserParser::MERGE:
        case sql_parserParser::MSCK:
        case sql_parserParser::NAMESPACE:
        case sql_parserParser::NAMESPACES:
        case sql_parserParser::NATURAL:
        case sql_parserParser::NO:
        case sql_parserParser::NOT:
        case sql_parserParser::NULL_:
        case sql_parserParser::NULLS:
        case sql_parserParser::OF:
        case sql_parserParser::ON:
        case sql_parserParser::ONLY:
        case sql_parserParser::OPTION:
        case sql_parserParser::OPTIONS:
        case sql_parserParser::OR:
        case sql_parserParser::ORDER:
        case sql_parserParser::OUT:
        case sql_parserParser::OUTER:
        case sql_parserParser::OUTPUTFORMAT:
        case sql_parserParser::OVER:
        case sql_parserParser::OVERLAPS:
        case sql_parserParser::OVERLAY:
        case sql_parserParser::OVERWRITE:
        case sql_parserParser::PARTITION:
        case sql_parserParser::PARTITIONED:
        case sql_parserParser::PARTITIONS:
        case sql_parserParser::PERCENTLIT:
        case sql_parserParser::PIVOT:
        case sql_parserParser::PLACING:
        case sql_parserParser::POSITION:
        case sql_parserParser::PRECEDING:
        case sql_parserParser::PRIMARY:
        case sql_parserParser::PRINCIPALS:
        case sql_parserParser::PROPERTIES:
        case sql_parserParser::PURGE:
        case sql_parserParser::QUERY:
        case sql_parserParser::RANGE:
        case sql_parserParser::RECORDREADER:
        case sql_parserParser::RECORDWRITER:
        case sql_parserParser::RECOVER:
        case sql_parserParser::REDUCE:
        case sql_parserParser::REFERENCES:
        case sql_parserParser::REFRESH:
        case sql_parserParser::RENAME:
        case sql_parserParser::REPAIR:
        case sql_parserParser::REPLACE:
        case sql_parserParser::RESET:
        case sql_parserParser::RESTRICT:
        case sql_parserParser::REVOKE:
        case sql_parserParser::RIGHT:
        case sql_parserParser::RLIKE:
        case sql_parserParser::ROLE:
        case sql_parserParser::ROLES:
        case sql_parserParser::ROLLBACK:
        case sql_parserParser::ROLLUP:
        case sql_parserParser::ROW:
        case sql_parserParser::ROWS:
        case sql_parserParser::SCHEMA:
        case sql_parserParser::SELECT:
        case sql_parserParser::SEMI:
        case sql_parserParser::SEPARATED:
        case sql_parserParser::SERDE:
        case sql_parserParser::SERDEPROPERTIES:
        case sql_parserParser::SESSION_USER:
        case sql_parserParser::SET:
        case sql_parserParser::SETMINUS:
        case sql_parserParser::SETS:
        case sql_parserParser::SHOW:
        case sql_parserParser::SKEWED:
        case sql_parserParser::SOME:
        case sql_parserParser::SORT:
        case sql_parserParser::SORTED:
        case sql_parserParser::START:
        case sql_parserParser::STATISTICS:
        case sql_parserParser::STORED:
        case sql_parserParser::STRATIFY:
        case sql_parserParser::STRUCT:
        case sql_parserParser::SUBSTR:
        case sql_parserParser::SUBSTRING:
        case sql_parserParser::TABLE:
        case sql_parserParser::TABLES:
        case sql_parserParser::TABLESAMPLE:
        case sql_parserParser::TBLPROPERTIES:
        case sql_parserParser::TEMPORARY:
        case sql_parserParser::TERMINATED:
        case sql_parserParser::THEN:
        case sql_parserParser::TO:
        case sql_parserParser::TOUCH:
        case sql_parserParser::TRAILING:
        case sql_parserParser::TRANSACTION:
        case sql_parserParser::TRANSACTIONS:
        case sql_parserParser::TRANSFORM:
        case sql_parserParser::TRIM:
        case sql_parserParser::TRUE:
        case sql_parserParser::TRUNCATE:
        case sql_parserParser::TYPE:
        case sql_parserParser::UNARCHIVE:
        case sql_parserParser::UNBOUNDED:
        case sql_parserParser::UNCACHE:
        case sql_parserParser::UNION:
        case sql_parserParser::UNIQUE:
        case sql_parserParser::UNKNOWN:
        case sql_parserParser::UNLOCK:
        case sql_parserParser::UNSET:
        case sql_parserParser::UPDATE:
        case sql_parserParser::USE:
        case sql_parserParser::USER:
        case sql_parserParser::USING:
        case sql_parserParser::VALUES:
        case sql_parserParser::VIEW:
        case sql_parserParser::VIEWS:
        case sql_parserParser::WHEN:
        case sql_parserParser::WHERE:
        case sql_parserParser::WINDOW:
        case sql_parserParser::WITH:
        case sql_parserParser::IDENTIFIER:
        case sql_parserParser::BACKQUOTED_IDENTIFIER: {
          setState(325);
          antlrcpp::downCast<NamedExpressionContext *>(_localctx)->name = errorCapturingIdentifier();
          break;
        }

        case sql_parserParser::T__2: {
          setState(326);
          identifierList();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamedExpressionSeqContext ------------------------------------------------------------------

sql_parserParser::NamedExpressionSeqContext::NamedExpressionSeqContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<sql_parserParser::NamedExpressionContext *> sql_parserParser::NamedExpressionSeqContext::namedExpression() {
  return getRuleContexts<sql_parserParser::NamedExpressionContext>();
}

sql_parserParser::NamedExpressionContext* sql_parserParser::NamedExpressionSeqContext::namedExpression(size_t i) {
  return getRuleContext<sql_parserParser::NamedExpressionContext>(i);
}


size_t sql_parserParser::NamedExpressionSeqContext::getRuleIndex() const {
  return sql_parserParser::RuleNamedExpressionSeq;
}


std::any sql_parserParser::NamedExpressionSeqContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitNamedExpressionSeq(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::NamedExpressionSeqContext* sql_parserParser::namedExpressionSeq() {
  NamedExpressionSeqContext *_localctx = _tracker.createInstance<NamedExpressionSeqContext>(_ctx, getState());
  enterRule(_localctx, 52, sql_parserParser::RuleNamedExpressionSeq);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(331);
    namedExpression();
    setState(336);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == sql_parserParser::T__1) {
      setState(332);
      match(sql_parserParser::T__1);
      setState(333);
      namedExpression();
      setState(338);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

sql_parserParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

sql_parserParser::BooleanExpressionContext* sql_parserParser::ExpressionContext::booleanExpression() {
  return getRuleContext<sql_parserParser::BooleanExpressionContext>(0);
}


size_t sql_parserParser::ExpressionContext::getRuleIndex() const {
  return sql_parserParser::RuleExpression;
}


std::any sql_parserParser::ExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitExpression(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::ExpressionContext* sql_parserParser::expression() {
  ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, getState());
  enterRule(_localctx, 54, sql_parserParser::RuleExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(339);
    booleanExpression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BooleanExpressionContext ------------------------------------------------------------------

sql_parserParser::BooleanExpressionContext::BooleanExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t sql_parserParser::BooleanExpressionContext::getRuleIndex() const {
  return sql_parserParser::RuleBooleanExpression;
}

void sql_parserParser::BooleanExpressionContext::copyFrom(BooleanExpressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- LogicalNotContext ------------------------------------------------------------------

tree::TerminalNode* sql_parserParser::LogicalNotContext::NOT() {
  return getToken(sql_parserParser::NOT, 0);
}

sql_parserParser::BooleanExpressionContext* sql_parserParser::LogicalNotContext::booleanExpression() {
  return getRuleContext<sql_parserParser::BooleanExpressionContext>(0);
}

sql_parserParser::LogicalNotContext::LogicalNotContext(BooleanExpressionContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::LogicalNotContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitLogicalNot(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PredicatedContext ------------------------------------------------------------------

sql_parserParser::ValueExpressionContext* sql_parserParser::PredicatedContext::valueExpression() {
  return getRuleContext<sql_parserParser::ValueExpressionContext>(0);
}

sql_parserParser::PredicateContext* sql_parserParser::PredicatedContext::predicate() {
  return getRuleContext<sql_parserParser::PredicateContext>(0);
}

sql_parserParser::PredicatedContext::PredicatedContext(BooleanExpressionContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::PredicatedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitPredicated(this);
  else
    return visitor->visitChildren(this);
}
//----------------- LogicalBinaryContext ------------------------------------------------------------------

std::vector<sql_parserParser::BooleanExpressionContext *> sql_parserParser::LogicalBinaryContext::booleanExpression() {
  return getRuleContexts<sql_parserParser::BooleanExpressionContext>();
}

sql_parserParser::BooleanExpressionContext* sql_parserParser::LogicalBinaryContext::booleanExpression(size_t i) {
  return getRuleContext<sql_parserParser::BooleanExpressionContext>(i);
}

tree::TerminalNode* sql_parserParser::LogicalBinaryContext::AND() {
  return getToken(sql_parserParser::AND, 0);
}

tree::TerminalNode* sql_parserParser::LogicalBinaryContext::OR() {
  return getToken(sql_parserParser::OR, 0);
}

sql_parserParser::LogicalBinaryContext::LogicalBinaryContext(BooleanExpressionContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::LogicalBinaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitLogicalBinary(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::BooleanExpressionContext* sql_parserParser::booleanExpression() {
   return booleanExpression(0);
}

sql_parserParser::BooleanExpressionContext* sql_parserParser::booleanExpression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  sql_parserParser::BooleanExpressionContext *_localctx = _tracker.createInstance<BooleanExpressionContext>(_ctx, parentState);
  sql_parserParser::BooleanExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 56;
  enterRecursionRule(_localctx, 56, sql_parserParser::RuleBooleanExpression, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(348);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<LogicalNotContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(342);
      match(sql_parserParser::NOT);
      setState(343);
      booleanExpression(4);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<PredicatedContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(344);
      valueExpression(0);
      setState(346);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx)) {
      case 1: {
        setState(345);
        predicate();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(358);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(356);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<LogicalBinaryContext>(_tracker.createInstance<BooleanExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleBooleanExpression);
          setState(350);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(351);
          antlrcpp::downCast<LogicalBinaryContext *>(_localctx)->operator_ = match(sql_parserParser::AND);
          setState(352);
          antlrcpp::downCast<LogicalBinaryContext *>(_localctx)->right = booleanExpression(3);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<LogicalBinaryContext>(_tracker.createInstance<BooleanExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleBooleanExpression);
          setState(353);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(354);
          antlrcpp::downCast<LogicalBinaryContext *>(_localctx)->operator_ = match(sql_parserParser::OR);
          setState(355);
          antlrcpp::downCast<LogicalBinaryContext *>(_localctx)->right = booleanExpression(2);
          break;
        }

        default:
          break;
        } 
      }
      setState(360);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- PredicateContext ------------------------------------------------------------------

sql_parserParser::PredicateContext::PredicateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* sql_parserParser::PredicateContext::AND() {
  return getToken(sql_parserParser::AND, 0);
}

tree::TerminalNode* sql_parserParser::PredicateContext::BETWEEN() {
  return getToken(sql_parserParser::BETWEEN, 0);
}

std::vector<sql_parserParser::ValueExpressionContext *> sql_parserParser::PredicateContext::valueExpression() {
  return getRuleContexts<sql_parserParser::ValueExpressionContext>();
}

sql_parserParser::ValueExpressionContext* sql_parserParser::PredicateContext::valueExpression(size_t i) {
  return getRuleContext<sql_parserParser::ValueExpressionContext>(i);
}

tree::TerminalNode* sql_parserParser::PredicateContext::NOT() {
  return getToken(sql_parserParser::NOT, 0);
}

std::vector<sql_parserParser::ExpressionContext *> sql_parserParser::PredicateContext::expression() {
  return getRuleContexts<sql_parserParser::ExpressionContext>();
}

sql_parserParser::ExpressionContext* sql_parserParser::PredicateContext::expression(size_t i) {
  return getRuleContext<sql_parserParser::ExpressionContext>(i);
}

tree::TerminalNode* sql_parserParser::PredicateContext::IN() {
  return getToken(sql_parserParser::IN, 0);
}

sql_parserParser::QueryContext* sql_parserParser::PredicateContext::query() {
  return getRuleContext<sql_parserParser::QueryContext>(0);
}

tree::TerminalNode* sql_parserParser::PredicateContext::RLIKE() {
  return getToken(sql_parserParser::RLIKE, 0);
}

tree::TerminalNode* sql_parserParser::PredicateContext::LIKE() {
  return getToken(sql_parserParser::LIKE, 0);
}

tree::TerminalNode* sql_parserParser::PredicateContext::ESCAPE() {
  return getToken(sql_parserParser::ESCAPE, 0);
}

tree::TerminalNode* sql_parserParser::PredicateContext::STRING() {
  return getToken(sql_parserParser::STRING, 0);
}

tree::TerminalNode* sql_parserParser::PredicateContext::IS() {
  return getToken(sql_parserParser::IS, 0);
}

tree::TerminalNode* sql_parserParser::PredicateContext::NULL_() {
  return getToken(sql_parserParser::NULL_, 0);
}

tree::TerminalNode* sql_parserParser::PredicateContext::TRUE() {
  return getToken(sql_parserParser::TRUE, 0);
}

tree::TerminalNode* sql_parserParser::PredicateContext::FALSE() {
  return getToken(sql_parserParser::FALSE, 0);
}

tree::TerminalNode* sql_parserParser::PredicateContext::UNKNOWN() {
  return getToken(sql_parserParser::UNKNOWN, 0);
}

tree::TerminalNode* sql_parserParser::PredicateContext::FROM() {
  return getToken(sql_parserParser::FROM, 0);
}

tree::TerminalNode* sql_parserParser::PredicateContext::DISTINCT() {
  return getToken(sql_parserParser::DISTINCT, 0);
}


size_t sql_parserParser::PredicateContext::getRuleIndex() const {
  return sql_parserParser::RulePredicate;
}


std::any sql_parserParser::PredicateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitPredicate(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::PredicateContext* sql_parserParser::predicate() {
  PredicateContext *_localctx = _tracker.createInstance<PredicateContext>(_ctx, getState());
  enterRule(_localctx, 58, sql_parserParser::RulePredicate);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(423);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(362);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == sql_parserParser::NOT) {
        setState(361);
        match(sql_parserParser::NOT);
      }
      setState(364);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(sql_parserParser::BETWEEN);
      setState(365);
      antlrcpp::downCast<PredicateContext *>(_localctx)->lower = valueExpression(0);
      setState(366);
      match(sql_parserParser::AND);
      setState(367);
      antlrcpp::downCast<PredicateContext *>(_localctx)->upper = valueExpression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(370);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == sql_parserParser::NOT) {
        setState(369);
        match(sql_parserParser::NOT);
      }
      setState(372);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(sql_parserParser::IN);
      setState(373);
      match(sql_parserParser::T__2);
      setState(374);
      expression();
      setState(379);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == sql_parserParser::T__1) {
        setState(375);
        match(sql_parserParser::T__1);
        setState(376);
        expression();
        setState(381);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(382);
      match(sql_parserParser::T__3);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(385);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == sql_parserParser::NOT) {
        setState(384);
        match(sql_parserParser::NOT);
      }
      setState(387);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(sql_parserParser::IN);
      setState(388);
      match(sql_parserParser::T__2);
      setState(389);
      query();
      setState(390);
      match(sql_parserParser::T__3);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(393);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == sql_parserParser::NOT) {
        setState(392);
        match(sql_parserParser::NOT);
      }
      setState(395);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(sql_parserParser::RLIKE);
      setState(396);
      antlrcpp::downCast<PredicateContext *>(_localctx)->pattern = valueExpression(0);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(398);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == sql_parserParser::NOT) {
        setState(397);
        match(sql_parserParser::NOT);
      }
      setState(400);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(sql_parserParser::LIKE);
      setState(401);
      antlrcpp::downCast<PredicateContext *>(_localctx)->pattern = valueExpression(0);
      setState(404);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx)) {
      case 1: {
        setState(402);
        match(sql_parserParser::ESCAPE);
        setState(403);
        antlrcpp::downCast<PredicateContext *>(_localctx)->escapeChar = match(sql_parserParser::STRING);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(406);
      match(sql_parserParser::IS);
      setState(408);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == sql_parserParser::NOT) {
        setState(407);
        match(sql_parserParser::NOT);
      }
      setState(410);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(sql_parserParser::NULL_);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(411);
      match(sql_parserParser::IS);
      setState(413);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == sql_parserParser::NOT) {
        setState(412);
        match(sql_parserParser::NOT);
      }
      setState(415);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == sql_parserParser::FALSE || _la == sql_parserParser::TRUE

      || _la == sql_parserParser::UNKNOWN)) {
        antlrcpp::downCast<PredicateContext *>(_localctx)->kind = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(416);
      match(sql_parserParser::IS);
      setState(418);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == sql_parserParser::NOT) {
        setState(417);
        match(sql_parserParser::NOT);
      }
      setState(420);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(sql_parserParser::DISTINCT);
      setState(421);
      match(sql_parserParser::FROM);
      setState(422);
      antlrcpp::downCast<PredicateContext *>(_localctx)->right = valueExpression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueExpressionContext ------------------------------------------------------------------

sql_parserParser::ValueExpressionContext::ValueExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t sql_parserParser::ValueExpressionContext::getRuleIndex() const {
  return sql_parserParser::RuleValueExpression;
}

void sql_parserParser::ValueExpressionContext::copyFrom(ValueExpressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- ValueExpressionDefaultContext ------------------------------------------------------------------

sql_parserParser::PrimaryExpressionContext* sql_parserParser::ValueExpressionDefaultContext::primaryExpression() {
  return getRuleContext<sql_parserParser::PrimaryExpressionContext>(0);
}

sql_parserParser::ValueExpressionDefaultContext::ValueExpressionDefaultContext(ValueExpressionContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::ValueExpressionDefaultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitValueExpressionDefault(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ComparisonContext ------------------------------------------------------------------

sql_parserParser::ComparisonOperatorContext* sql_parserParser::ComparisonContext::comparisonOperator() {
  return getRuleContext<sql_parserParser::ComparisonOperatorContext>(0);
}

std::vector<sql_parserParser::ValueExpressionContext *> sql_parserParser::ComparisonContext::valueExpression() {
  return getRuleContexts<sql_parserParser::ValueExpressionContext>();
}

sql_parserParser::ValueExpressionContext* sql_parserParser::ComparisonContext::valueExpression(size_t i) {
  return getRuleContext<sql_parserParser::ValueExpressionContext>(i);
}

sql_parserParser::ComparisonContext::ComparisonContext(ValueExpressionContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::ComparisonContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitComparison(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ArithmeticBinaryContext ------------------------------------------------------------------

std::vector<sql_parserParser::ValueExpressionContext *> sql_parserParser::ArithmeticBinaryContext::valueExpression() {
  return getRuleContexts<sql_parserParser::ValueExpressionContext>();
}

sql_parserParser::ValueExpressionContext* sql_parserParser::ArithmeticBinaryContext::valueExpression(size_t i) {
  return getRuleContext<sql_parserParser::ValueExpressionContext>(i);
}

tree::TerminalNode* sql_parserParser::ArithmeticBinaryContext::ASTERISK() {
  return getToken(sql_parserParser::ASTERISK, 0);
}

tree::TerminalNode* sql_parserParser::ArithmeticBinaryContext::SLASH() {
  return getToken(sql_parserParser::SLASH, 0);
}

tree::TerminalNode* sql_parserParser::ArithmeticBinaryContext::PERCENT() {
  return getToken(sql_parserParser::PERCENT, 0);
}

tree::TerminalNode* sql_parserParser::ArithmeticBinaryContext::DIV() {
  return getToken(sql_parserParser::DIV, 0);
}

tree::TerminalNode* sql_parserParser::ArithmeticBinaryContext::PLUS() {
  return getToken(sql_parserParser::PLUS, 0);
}

tree::TerminalNode* sql_parserParser::ArithmeticBinaryContext::MINUS() {
  return getToken(sql_parserParser::MINUS, 0);
}

tree::TerminalNode* sql_parserParser::ArithmeticBinaryContext::CONCAT_PIPE() {
  return getToken(sql_parserParser::CONCAT_PIPE, 0);
}

tree::TerminalNode* sql_parserParser::ArithmeticBinaryContext::AMPERSAND() {
  return getToken(sql_parserParser::AMPERSAND, 0);
}

tree::TerminalNode* sql_parserParser::ArithmeticBinaryContext::HAT() {
  return getToken(sql_parserParser::HAT, 0);
}

tree::TerminalNode* sql_parserParser::ArithmeticBinaryContext::PIPE() {
  return getToken(sql_parserParser::PIPE, 0);
}

sql_parserParser::ArithmeticBinaryContext::ArithmeticBinaryContext(ValueExpressionContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::ArithmeticBinaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitArithmeticBinary(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ArithmeticUnaryContext ------------------------------------------------------------------

sql_parserParser::ValueExpressionContext* sql_parserParser::ArithmeticUnaryContext::valueExpression() {
  return getRuleContext<sql_parserParser::ValueExpressionContext>(0);
}

tree::TerminalNode* sql_parserParser::ArithmeticUnaryContext::MINUS() {
  return getToken(sql_parserParser::MINUS, 0);
}

tree::TerminalNode* sql_parserParser::ArithmeticUnaryContext::PLUS() {
  return getToken(sql_parserParser::PLUS, 0);
}

tree::TerminalNode* sql_parserParser::ArithmeticUnaryContext::TILDE() {
  return getToken(sql_parserParser::TILDE, 0);
}

sql_parserParser::ArithmeticUnaryContext::ArithmeticUnaryContext(ValueExpressionContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::ArithmeticUnaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitArithmeticUnary(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::ValueExpressionContext* sql_parserParser::valueExpression() {
   return valueExpression(0);
}

sql_parserParser::ValueExpressionContext* sql_parserParser::valueExpression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  sql_parserParser::ValueExpressionContext *_localctx = _tracker.createInstance<ValueExpressionContext>(_ctx, parentState);
  sql_parserParser::ValueExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 60;
  enterRecursionRule(_localctx, 60, sql_parserParser::RuleValueExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(429);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<ValueExpressionDefaultContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(426);
      primaryExpression(0);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<ArithmeticUnaryContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(427);
      antlrcpp::downCast<ArithmeticUnaryContext *>(_localctx)->operator_ = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 264) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 264)) & 35) != 0))) {
        antlrcpp::downCast<ArithmeticUnaryContext *>(_localctx)->operator_ = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(428);
      valueExpression(7);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(452);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(450);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleValueExpression);
          setState(431);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(432);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->operator_ = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == sql_parserParser::DIV || ((((_la - 266) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 266)) & 7) != 0))) {
            antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->operator_ = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(433);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->right = valueExpression(7);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleValueExpression);
          setState(434);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(435);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->operator_ = _input->LT(1);
          _la = _input->LA(1);
          if (!(((((_la - 264) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 264)) & 259) != 0))) {
            antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->operator_ = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(436);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->right = valueExpression(6);
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleValueExpression);
          setState(437);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(438);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->operator_ = match(sql_parserParser::AMPERSAND);
          setState(439);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->right = valueExpression(5);
          break;
        }

        case 4: {
          auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleValueExpression);
          setState(440);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(441);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->operator_ = match(sql_parserParser::HAT);
          setState(442);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->right = valueExpression(4);
          break;
        }

        case 5: {
          auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleValueExpression);
          setState(443);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(444);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->operator_ = match(sql_parserParser::PIPE);
          setState(445);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->right = valueExpression(3);
          break;
        }

        case 6: {
          auto newContext = _tracker.createInstance<ComparisonContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleValueExpression);
          setState(446);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(447);
          comparisonOperator();
          setState(448);
          antlrcpp::downCast<ComparisonContext *>(_localctx)->right = valueExpression(2);
          break;
        }

        default:
          break;
        } 
      }
      setState(454);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- PrimaryExpressionContext ------------------------------------------------------------------

sql_parserParser::PrimaryExpressionContext::PrimaryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t sql_parserParser::PrimaryExpressionContext::getRuleIndex() const {
  return sql_parserParser::RulePrimaryExpression;
}

void sql_parserParser::PrimaryExpressionContext::copyFrom(PrimaryExpressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- StructContext ------------------------------------------------------------------

tree::TerminalNode* sql_parserParser::StructContext::STRUCT() {
  return getToken(sql_parserParser::STRUCT, 0);
}

std::vector<sql_parserParser::NamedExpressionContext *> sql_parserParser::StructContext::namedExpression() {
  return getRuleContexts<sql_parserParser::NamedExpressionContext>();
}

sql_parserParser::NamedExpressionContext* sql_parserParser::StructContext::namedExpression(size_t i) {
  return getRuleContext<sql_parserParser::NamedExpressionContext>(i);
}

sql_parserParser::StructContext::StructContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::StructContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitStruct(this);
  else
    return visitor->visitChildren(this);
}
//----------------- DereferenceContext ------------------------------------------------------------------

sql_parserParser::PrimaryExpressionContext* sql_parserParser::DereferenceContext::primaryExpression() {
  return getRuleContext<sql_parserParser::PrimaryExpressionContext>(0);
}

sql_parserParser::IdentifierContext* sql_parserParser::DereferenceContext::identifier() {
  return getRuleContext<sql_parserParser::IdentifierContext>(0);
}

sql_parserParser::DereferenceContext::DereferenceContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::DereferenceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitDereference(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleCaseContext ------------------------------------------------------------------

tree::TerminalNode* sql_parserParser::SimpleCaseContext::CASE() {
  return getToken(sql_parserParser::CASE, 0);
}

tree::TerminalNode* sql_parserParser::SimpleCaseContext::END() {
  return getToken(sql_parserParser::END, 0);
}

std::vector<sql_parserParser::ExpressionContext *> sql_parserParser::SimpleCaseContext::expression() {
  return getRuleContexts<sql_parserParser::ExpressionContext>();
}

sql_parserParser::ExpressionContext* sql_parserParser::SimpleCaseContext::expression(size_t i) {
  return getRuleContext<sql_parserParser::ExpressionContext>(i);
}

std::vector<sql_parserParser::WhenClauseContext *> sql_parserParser::SimpleCaseContext::whenClause() {
  return getRuleContexts<sql_parserParser::WhenClauseContext>();
}

sql_parserParser::WhenClauseContext* sql_parserParser::SimpleCaseContext::whenClause(size_t i) {
  return getRuleContext<sql_parserParser::WhenClauseContext>(i);
}

tree::TerminalNode* sql_parserParser::SimpleCaseContext::ELSE() {
  return getToken(sql_parserParser::ELSE, 0);
}

sql_parserParser::SimpleCaseContext::SimpleCaseContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::SimpleCaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitSimpleCase(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ColumnReferenceContext ------------------------------------------------------------------

sql_parserParser::IdentifierContext* sql_parserParser::ColumnReferenceContext::identifier() {
  return getRuleContext<sql_parserParser::IdentifierContext>(0);
}

sql_parserParser::ColumnReferenceContext::ColumnReferenceContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::ColumnReferenceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitColumnReference(this);
  else
    return visitor->visitChildren(this);
}
//----------------- RowConstructorContext ------------------------------------------------------------------

std::vector<sql_parserParser::NamedExpressionContext *> sql_parserParser::RowConstructorContext::namedExpression() {
  return getRuleContexts<sql_parserParser::NamedExpressionContext>();
}

sql_parserParser::NamedExpressionContext* sql_parserParser::RowConstructorContext::namedExpression(size_t i) {
  return getRuleContext<sql_parserParser::NamedExpressionContext>(i);
}

sql_parserParser::RowConstructorContext::RowConstructorContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::RowConstructorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitRowConstructor(this);
  else
    return visitor->visitChildren(this);
}
//----------------- LastContext ------------------------------------------------------------------

tree::TerminalNode* sql_parserParser::LastContext::LAST() {
  return getToken(sql_parserParser::LAST, 0);
}

sql_parserParser::ExpressionContext* sql_parserParser::LastContext::expression() {
  return getRuleContext<sql_parserParser::ExpressionContext>(0);
}

tree::TerminalNode* sql_parserParser::LastContext::IGNORE() {
  return getToken(sql_parserParser::IGNORE, 0);
}

tree::TerminalNode* sql_parserParser::LastContext::NULLS() {
  return getToken(sql_parserParser::NULLS, 0);
}

sql_parserParser::LastContext::LastContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::LastContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitLast(this);
  else
    return visitor->visitChildren(this);
}
//----------------- StarContext ------------------------------------------------------------------

tree::TerminalNode* sql_parserParser::StarContext::ASTERISK() {
  return getToken(sql_parserParser::ASTERISK, 0);
}

sql_parserParser::QualifiedNameContext* sql_parserParser::StarContext::qualifiedName() {
  return getRuleContext<sql_parserParser::QualifiedNameContext>(0);
}

sql_parserParser::StarContext::StarContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::StarContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitStar(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SubscriptContext ------------------------------------------------------------------

sql_parserParser::PrimaryExpressionContext* sql_parserParser::SubscriptContext::primaryExpression() {
  return getRuleContext<sql_parserParser::PrimaryExpressionContext>(0);
}

sql_parserParser::ValueExpressionContext* sql_parserParser::SubscriptContext::valueExpression() {
  return getRuleContext<sql_parserParser::ValueExpressionContext>(0);
}

sql_parserParser::SubscriptContext::SubscriptContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::SubscriptContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitSubscript(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SubqueryExpressionContext ------------------------------------------------------------------

sql_parserParser::QueryContext* sql_parserParser::SubqueryExpressionContext::query() {
  return getRuleContext<sql_parserParser::QueryContext>(0);
}

sql_parserParser::SubqueryExpressionContext::SubqueryExpressionContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::SubqueryExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitSubqueryExpression(this);
  else
    return visitor->visitChildren(this);
}
//----------------- CurrentDatetimeContext ------------------------------------------------------------------

tree::TerminalNode* sql_parserParser::CurrentDatetimeContext::CURRENT_DATE() {
  return getToken(sql_parserParser::CURRENT_DATE, 0);
}

tree::TerminalNode* sql_parserParser::CurrentDatetimeContext::CURRENT_TIMESTAMP() {
  return getToken(sql_parserParser::CURRENT_TIMESTAMP, 0);
}

sql_parserParser::CurrentDatetimeContext::CurrentDatetimeContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::CurrentDatetimeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitCurrentDatetime(this);
  else
    return visitor->visitChildren(this);
}
//----------------- CastContext ------------------------------------------------------------------

tree::TerminalNode* sql_parserParser::CastContext::CAST() {
  return getToken(sql_parserParser::CAST, 0);
}

sql_parserParser::ExpressionContext* sql_parserParser::CastContext::expression() {
  return getRuleContext<sql_parserParser::ExpressionContext>(0);
}

tree::TerminalNode* sql_parserParser::CastContext::AS() {
  return getToken(sql_parserParser::AS, 0);
}

sql_parserParser::DataTypeContext* sql_parserParser::CastContext::dataType() {
  return getRuleContext<sql_parserParser::DataTypeContext>(0);
}

sql_parserParser::CastContext::CastContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::CastContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitCast(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ConstantDefaultContext ------------------------------------------------------------------

sql_parserParser::ConstantContext* sql_parserParser::ConstantDefaultContext::constant() {
  return getRuleContext<sql_parserParser::ConstantContext>(0);
}

sql_parserParser::ConstantDefaultContext::ConstantDefaultContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::ConstantDefaultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitConstantDefault(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ParenthesizedExpressionContext ------------------------------------------------------------------

sql_parserParser::ExpressionContext* sql_parserParser::ParenthesizedExpressionContext::expression() {
  return getRuleContext<sql_parserParser::ExpressionContext>(0);
}

sql_parserParser::ParenthesizedExpressionContext::ParenthesizedExpressionContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::ParenthesizedExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitParenthesizedExpression(this);
  else
    return visitor->visitChildren(this);
}
//----------------- FunctionCallContext ------------------------------------------------------------------

sql_parserParser::FunctionNameContext* sql_parserParser::FunctionCallContext::functionName() {
  return getRuleContext<sql_parserParser::FunctionNameContext>(0);
}

std::vector<sql_parserParser::ExpressionContext *> sql_parserParser::FunctionCallContext::expression() {
  return getRuleContexts<sql_parserParser::ExpressionContext>();
}

sql_parserParser::ExpressionContext* sql_parserParser::FunctionCallContext::expression(size_t i) {
  return getRuleContext<sql_parserParser::ExpressionContext>(i);
}

sql_parserParser::FunctionCallContext::FunctionCallContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::FunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitFunctionCall(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SearchedCaseContext ------------------------------------------------------------------

tree::TerminalNode* sql_parserParser::SearchedCaseContext::CASE() {
  return getToken(sql_parserParser::CASE, 0);
}

tree::TerminalNode* sql_parserParser::SearchedCaseContext::END() {
  return getToken(sql_parserParser::END, 0);
}

std::vector<sql_parserParser::WhenClauseContext *> sql_parserParser::SearchedCaseContext::whenClause() {
  return getRuleContexts<sql_parserParser::WhenClauseContext>();
}

sql_parserParser::WhenClauseContext* sql_parserParser::SearchedCaseContext::whenClause(size_t i) {
  return getRuleContext<sql_parserParser::WhenClauseContext>(i);
}

tree::TerminalNode* sql_parserParser::SearchedCaseContext::ELSE() {
  return getToken(sql_parserParser::ELSE, 0);
}

sql_parserParser::ExpressionContext* sql_parserParser::SearchedCaseContext::expression() {
  return getRuleContext<sql_parserParser::ExpressionContext>(0);
}

sql_parserParser::SearchedCaseContext::SearchedCaseContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::SearchedCaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitSearchedCase(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PositionContext ------------------------------------------------------------------

tree::TerminalNode* sql_parserParser::PositionContext::POSITION() {
  return getToken(sql_parserParser::POSITION, 0);
}

tree::TerminalNode* sql_parserParser::PositionContext::IN() {
  return getToken(sql_parserParser::IN, 0);
}

std::vector<sql_parserParser::ValueExpressionContext *> sql_parserParser::PositionContext::valueExpression() {
  return getRuleContexts<sql_parserParser::ValueExpressionContext>();
}

sql_parserParser::ValueExpressionContext* sql_parserParser::PositionContext::valueExpression(size_t i) {
  return getRuleContext<sql_parserParser::ValueExpressionContext>(i);
}

sql_parserParser::PositionContext::PositionContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::PositionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitPosition(this);
  else
    return visitor->visitChildren(this);
}
//----------------- FirstContext ------------------------------------------------------------------

tree::TerminalNode* sql_parserParser::FirstContext::FIRST() {
  return getToken(sql_parserParser::FIRST, 0);
}

sql_parserParser::ExpressionContext* sql_parserParser::FirstContext::expression() {
  return getRuleContext<sql_parserParser::ExpressionContext>(0);
}

tree::TerminalNode* sql_parserParser::FirstContext::IGNORE() {
  return getToken(sql_parserParser::IGNORE, 0);
}

tree::TerminalNode* sql_parserParser::FirstContext::NULLS() {
  return getToken(sql_parserParser::NULLS, 0);
}

sql_parserParser::FirstContext::FirstContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::FirstContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitFirst(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::PrimaryExpressionContext* sql_parserParser::primaryExpression() {
   return primaryExpression(0);
}

sql_parserParser::PrimaryExpressionContext* sql_parserParser::primaryExpression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  sql_parserParser::PrimaryExpressionContext *_localctx = _tracker.createInstance<PrimaryExpressionContext>(_ctx, parentState);
  sql_parserParser::PrimaryExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 62;
  enterRecursionRule(_localctx, 62, sql_parserParser::RulePrimaryExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(566);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<CurrentDatetimeContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(456);
      antlrcpp::downCast<CurrentDatetimeContext *>(_localctx)->name = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == sql_parserParser::CURRENT_DATE

      || _la == sql_parserParser::CURRENT_TIMESTAMP)) {
        antlrcpp::downCast<CurrentDatetimeContext *>(_localctx)->name = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<SearchedCaseContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(457);
      match(sql_parserParser::CASE);
      setState(459); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(458);
        whenClause();
        setState(461); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == sql_parserParser::WHEN);
      setState(465);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == sql_parserParser::ELSE) {
        setState(463);
        match(sql_parserParser::ELSE);
        setState(464);
        antlrcpp::downCast<SearchedCaseContext *>(_localctx)->elseExpression = expression();
      }
      setState(467);
      match(sql_parserParser::END);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<SimpleCaseContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(469);
      match(sql_parserParser::CASE);
      setState(470);
      antlrcpp::downCast<SimpleCaseContext *>(_localctx)->value = expression();
      setState(472); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(471);
        whenClause();
        setState(474); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == sql_parserParser::WHEN);
      setState(478);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == sql_parserParser::ELSE) {
        setState(476);
        match(sql_parserParser::ELSE);
        setState(477);
        antlrcpp::downCast<SimpleCaseContext *>(_localctx)->elseExpression = expression();
      }
      setState(480);
      match(sql_parserParser::END);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<CastContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(482);
      match(sql_parserParser::CAST);
      setState(483);
      match(sql_parserParser::T__2);
      setState(484);
      expression();
      setState(485);
      match(sql_parserParser::AS);
      setState(486);
      dataType();
      setState(487);
      match(sql_parserParser::T__3);
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<StructContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(489);
      match(sql_parserParser::STRUCT);
      setState(490);
      match(sql_parserParser::T__2);
      setState(499);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -504) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & -1) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & -1) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 192)) & -1) != 0) || ((((_la - 264) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 264)) & 2096167) != 0)) {
        setState(491);
        antlrcpp::downCast<StructContext *>(_localctx)->namedExpressionContext = namedExpression();
        antlrcpp::downCast<StructContext *>(_localctx)->argument.push_back(antlrcpp::downCast<StructContext *>(_localctx)->namedExpressionContext);
        setState(496);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == sql_parserParser::T__1) {
          setState(492);
          match(sql_parserParser::T__1);
          setState(493);
          antlrcpp::downCast<StructContext *>(_localctx)->namedExpressionContext = namedExpression();
          antlrcpp::downCast<StructContext *>(_localctx)->argument.push_back(antlrcpp::downCast<StructContext *>(_localctx)->namedExpressionContext);
          setState(498);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
      }
      setState(501);
      match(sql_parserParser::T__3);
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<FirstContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(502);
      match(sql_parserParser::FIRST);
      setState(503);
      match(sql_parserParser::T__2);
      setState(504);
      expression();
      setState(507);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == sql_parserParser::IGNORE) {
        setState(505);
        match(sql_parserParser::IGNORE);
        setState(506);
        match(sql_parserParser::NULLS);
      }
      setState(509);
      match(sql_parserParser::T__3);
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<LastContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(511);
      match(sql_parserParser::LAST);
      setState(512);
      match(sql_parserParser::T__2);
      setState(513);
      expression();
      setState(516);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == sql_parserParser::IGNORE) {
        setState(514);
        match(sql_parserParser::IGNORE);
        setState(515);
        match(sql_parserParser::NULLS);
      }
      setState(518);
      match(sql_parserParser::T__3);
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<PositionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(520);
      match(sql_parserParser::POSITION);
      setState(521);
      match(sql_parserParser::T__2);
      setState(522);
      antlrcpp::downCast<PositionContext *>(_localctx)->substr = valueExpression(0);
      setState(523);
      match(sql_parserParser::IN);
      setState(524);
      antlrcpp::downCast<PositionContext *>(_localctx)->str = valueExpression(0);
      setState(525);
      match(sql_parserParser::T__3);
      break;
    }

    case 9: {
      _localctx = _tracker.createInstance<ConstantDefaultContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(527);
      constant();
      break;
    }

    case 10: {
      _localctx = _tracker.createInstance<StarContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(528);
      match(sql_parserParser::ASTERISK);
      break;
    }

    case 11: {
      _localctx = _tracker.createInstance<StarContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(529);
      qualifiedName();
      setState(530);
      match(sql_parserParser::T__4);
      setState(531);
      match(sql_parserParser::ASTERISK);
      break;
    }

    case 12: {
      _localctx = _tracker.createInstance<RowConstructorContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(533);
      match(sql_parserParser::T__2);
      setState(534);
      namedExpression();
      setState(537); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(535);
        match(sql_parserParser::T__1);
        setState(536);
        namedExpression();
        setState(539); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == sql_parserParser::T__1);
      setState(541);
      match(sql_parserParser::T__3);
      break;
    }

    case 13: {
      _localctx = _tracker.createInstance<SubqueryExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(543);
      match(sql_parserParser::T__2);
      setState(544);
      query();
      setState(545);
      match(sql_parserParser::T__3);
      break;
    }

    case 14: {
      _localctx = _tracker.createInstance<FunctionCallContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(547);
      functionName();
      setState(548);
      match(sql_parserParser::T__2);
      setState(557);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -504) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & -1) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & -1) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 192)) & -1) != 0) || ((((_la - 264) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 264)) & 2096167) != 0)) {
        setState(549);
        antlrcpp::downCast<FunctionCallContext *>(_localctx)->expressionContext = expression();
        antlrcpp::downCast<FunctionCallContext *>(_localctx)->argument.push_back(antlrcpp::downCast<FunctionCallContext *>(_localctx)->expressionContext);
        setState(554);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == sql_parserParser::T__1) {
          setState(550);
          match(sql_parserParser::T__1);
          setState(551);
          antlrcpp::downCast<FunctionCallContext *>(_localctx)->expressionContext = expression();
          antlrcpp::downCast<FunctionCallContext *>(_localctx)->argument.push_back(antlrcpp::downCast<FunctionCallContext *>(_localctx)->expressionContext);
          setState(556);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
      }
      setState(559);
      match(sql_parserParser::T__3);
      break;
    }

    case 15: {
      _localctx = _tracker.createInstance<ColumnReferenceContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(561);
      identifier();
      break;
    }

    case 16: {
      _localctx = _tracker.createInstance<ParenthesizedExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(562);
      match(sql_parserParser::T__2);
      setState(563);
      expression();
      setState(564);
      match(sql_parserParser::T__3);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(578);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(576);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<SubscriptContext>(_tracker.createInstance<PrimaryExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->value = previousContext;
          pushNewRecursionContext(newContext, startState, RulePrimaryExpression);
          setState(568);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(569);
          match(sql_parserParser::T__5);
          setState(570);
          antlrcpp::downCast<SubscriptContext *>(_localctx)->index = valueExpression(0);
          setState(571);
          match(sql_parserParser::T__6);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<DereferenceContext>(_tracker.createInstance<PrimaryExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->base = previousContext;
          pushNewRecursionContext(newContext, startState, RulePrimaryExpression);
          setState(573);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(574);
          match(sql_parserParser::T__4);
          setState(575);
          antlrcpp::downCast<DereferenceContext *>(_localctx)->fieldName = identifier();
          break;
        }

        default:
          break;
        } 
      }
      setState(580);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- ConstantContext ------------------------------------------------------------------

sql_parserParser::ConstantContext::ConstantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t sql_parserParser::ConstantContext::getRuleIndex() const {
  return sql_parserParser::RuleConstant;
}

void sql_parserParser::ConstantContext::copyFrom(ConstantContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- NullLiteralContext ------------------------------------------------------------------

tree::TerminalNode* sql_parserParser::NullLiteralContext::NULL_() {
  return getToken(sql_parserParser::NULL_, 0);
}

sql_parserParser::NullLiteralContext::NullLiteralContext(ConstantContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::NullLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitNullLiteral(this);
  else
    return visitor->visitChildren(this);
}
//----------------- StringLiteralContext ------------------------------------------------------------------

std::vector<tree::TerminalNode *> sql_parserParser::StringLiteralContext::STRING() {
  return getTokens(sql_parserParser::STRING);
}

tree::TerminalNode* sql_parserParser::StringLiteralContext::STRING(size_t i) {
  return getToken(sql_parserParser::STRING, i);
}

sql_parserParser::StringLiteralContext::StringLiteralContext(ConstantContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::StringLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitStringLiteral(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TypeConstructorContext ------------------------------------------------------------------

sql_parserParser::IdentifierContext* sql_parserParser::TypeConstructorContext::identifier() {
  return getRuleContext<sql_parserParser::IdentifierContext>(0);
}

tree::TerminalNode* sql_parserParser::TypeConstructorContext::STRING() {
  return getToken(sql_parserParser::STRING, 0);
}

sql_parserParser::TypeConstructorContext::TypeConstructorContext(ConstantContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::TypeConstructorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitTypeConstructor(this);
  else
    return visitor->visitChildren(this);
}
//----------------- IntervalLiteralContext ------------------------------------------------------------------

sql_parserParser::IntervalContext* sql_parserParser::IntervalLiteralContext::interval() {
  return getRuleContext<sql_parserParser::IntervalContext>(0);
}

sql_parserParser::IntervalLiteralContext::IntervalLiteralContext(ConstantContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::IntervalLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitIntervalLiteral(this);
  else
    return visitor->visitChildren(this);
}
//----------------- NumericLiteralContext ------------------------------------------------------------------

sql_parserParser::NumberContext* sql_parserParser::NumericLiteralContext::number() {
  return getRuleContext<sql_parserParser::NumberContext>(0);
}

sql_parserParser::NumericLiteralContext::NumericLiteralContext(ConstantContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::NumericLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitNumericLiteral(this);
  else
    return visitor->visitChildren(this);
}
//----------------- BooleanLiteralContext ------------------------------------------------------------------

sql_parserParser::BooleanValueContext* sql_parserParser::BooleanLiteralContext::booleanValue() {
  return getRuleContext<sql_parserParser::BooleanValueContext>(0);
}

sql_parserParser::BooleanLiteralContext::BooleanLiteralContext(ConstantContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::BooleanLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitBooleanLiteral(this);
  else
    return visitor->visitChildren(this);
}
sql_parserParser::ConstantContext* sql_parserParser::constant() {
  ConstantContext *_localctx = _tracker.createInstance<ConstantContext>(_ctx, getState());
  enterRule(_localctx, 64, sql_parserParser::RuleConstant);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(593);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<sql_parserParser::NullLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(581);
      match(sql_parserParser::NULL_);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<sql_parserParser::IntervalLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(582);
      interval();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<sql_parserParser::TypeConstructorContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(583);
      identifier();
      setState(584);
      match(sql_parserParser::STRING);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<sql_parserParser::NumericLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(586);
      number();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<sql_parserParser::BooleanLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(587);
      booleanValue();
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<sql_parserParser::StringLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(589); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(588);
                match(sql_parserParser::STRING);
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(591); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComparisonOperatorContext ------------------------------------------------------------------

sql_parserParser::ComparisonOperatorContext::ComparisonOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* sql_parserParser::ComparisonOperatorContext::EQ() {
  return getToken(sql_parserParser::EQ, 0);
}

tree::TerminalNode* sql_parserParser::ComparisonOperatorContext::NEQ() {
  return getToken(sql_parserParser::NEQ, 0);
}

tree::TerminalNode* sql_parserParser::ComparisonOperatorContext::NEQJ() {
  return getToken(sql_parserParser::NEQJ, 0);
}

tree::TerminalNode* sql_parserParser::ComparisonOperatorContext::LT() {
  return getToken(sql_parserParser::LT, 0);
}

tree::TerminalNode* sql_parserParser::ComparisonOperatorContext::LTE() {
  return getToken(sql_parserParser::LTE, 0);
}

tree::TerminalNode* sql_parserParser::ComparisonOperatorContext::GT() {
  return getToken(sql_parserParser::GT, 0);
}

tree::TerminalNode* sql_parserParser::ComparisonOperatorContext::GTE() {
  return getToken(sql_parserParser::GTE, 0);
}

tree::TerminalNode* sql_parserParser::ComparisonOperatorContext::NSEQ() {
  return getToken(sql_parserParser::NSEQ, 0);
}


size_t sql_parserParser::ComparisonOperatorContext::getRuleIndex() const {
  return sql_parserParser::RuleComparisonOperator;
}


std::any sql_parserParser::ComparisonOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitComparisonOperator(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::ComparisonOperatorContext* sql_parserParser::comparisonOperator() {
  ComparisonOperatorContext *_localctx = _tracker.createInstance<ComparisonOperatorContext>(_ctx, getState());
  enterRule(_localctx, 66, sql_parserParser::RuleComparisonOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(595);
    _la = _input->LA(1);
    if (!(((((_la - 256) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 256)) & 255) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArithmeticOperatorContext ------------------------------------------------------------------

sql_parserParser::ArithmeticOperatorContext::ArithmeticOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* sql_parserParser::ArithmeticOperatorContext::PLUS() {
  return getToken(sql_parserParser::PLUS, 0);
}

tree::TerminalNode* sql_parserParser::ArithmeticOperatorContext::MINUS() {
  return getToken(sql_parserParser::MINUS, 0);
}

tree::TerminalNode* sql_parserParser::ArithmeticOperatorContext::ASTERISK() {
  return getToken(sql_parserParser::ASTERISK, 0);
}

tree::TerminalNode* sql_parserParser::ArithmeticOperatorContext::SLASH() {
  return getToken(sql_parserParser::SLASH, 0);
}

tree::TerminalNode* sql_parserParser::ArithmeticOperatorContext::PERCENT() {
  return getToken(sql_parserParser::PERCENT, 0);
}

tree::TerminalNode* sql_parserParser::ArithmeticOperatorContext::DIV() {
  return getToken(sql_parserParser::DIV, 0);
}

tree::TerminalNode* sql_parserParser::ArithmeticOperatorContext::TILDE() {
  return getToken(sql_parserParser::TILDE, 0);
}

tree::TerminalNode* sql_parserParser::ArithmeticOperatorContext::AMPERSAND() {
  return getToken(sql_parserParser::AMPERSAND, 0);
}

tree::TerminalNode* sql_parserParser::ArithmeticOperatorContext::PIPE() {
  return getToken(sql_parserParser::PIPE, 0);
}

tree::TerminalNode* sql_parserParser::ArithmeticOperatorContext::CONCAT_PIPE() {
  return getToken(sql_parserParser::CONCAT_PIPE, 0);
}

tree::TerminalNode* sql_parserParser::ArithmeticOperatorContext::HAT() {
  return getToken(sql_parserParser::HAT, 0);
}


size_t sql_parserParser::ArithmeticOperatorContext::getRuleIndex() const {
  return sql_parserParser::RuleArithmeticOperator;
}


std::any sql_parserParser::ArithmeticOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitArithmeticOperator(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::ArithmeticOperatorContext* sql_parserParser::arithmeticOperator() {
  ArithmeticOperatorContext *_localctx = _tracker.createInstance<ArithmeticOperatorContext>(_ctx, getState());
  enterRule(_localctx, 68, sql_parserParser::RuleArithmeticOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(597);
    _la = _input->LA(1);
    if (!(_la == sql_parserParser::DIV || ((((_la - 264) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 264)) & 1023) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PredicateOperatorContext ------------------------------------------------------------------

sql_parserParser::PredicateOperatorContext::PredicateOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* sql_parserParser::PredicateOperatorContext::OR() {
  return getToken(sql_parserParser::OR, 0);
}

tree::TerminalNode* sql_parserParser::PredicateOperatorContext::AND() {
  return getToken(sql_parserParser::AND, 0);
}

tree::TerminalNode* sql_parserParser::PredicateOperatorContext::IN() {
  return getToken(sql_parserParser::IN, 0);
}

tree::TerminalNode* sql_parserParser::PredicateOperatorContext::NOT() {
  return getToken(sql_parserParser::NOT, 0);
}


size_t sql_parserParser::PredicateOperatorContext::getRuleIndex() const {
  return sql_parserParser::RulePredicateOperator;
}


std::any sql_parserParser::PredicateOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitPredicateOperator(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::PredicateOperatorContext* sql_parserParser::predicateOperator() {
  PredicateOperatorContext *_localctx = _tracker.createInstance<PredicateOperatorContext>(_ctx, getState());
  enterRule(_localctx, 70, sql_parserParser::RulePredicateOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(599);
    _la = _input->LA(1);
    if (!(_la == sql_parserParser::AND || ((((_la - 109) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 109)) & 70643622084609) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BooleanValueContext ------------------------------------------------------------------

sql_parserParser::BooleanValueContext::BooleanValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* sql_parserParser::BooleanValueContext::TRUE() {
  return getToken(sql_parserParser::TRUE, 0);
}

tree::TerminalNode* sql_parserParser::BooleanValueContext::FALSE() {
  return getToken(sql_parserParser::FALSE, 0);
}


size_t sql_parserParser::BooleanValueContext::getRuleIndex() const {
  return sql_parserParser::RuleBooleanValue;
}


std::any sql_parserParser::BooleanValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitBooleanValue(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::BooleanValueContext* sql_parserParser::booleanValue() {
  BooleanValueContext *_localctx = _tracker.createInstance<BooleanValueContext>(_ctx, getState());
  enterRule(_localctx, 72, sql_parserParser::RuleBooleanValue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(601);
    _la = _input->LA(1);
    if (!(_la == sql_parserParser::FALSE || _la == sql_parserParser::TRUE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntervalContext ------------------------------------------------------------------

sql_parserParser::IntervalContext::IntervalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* sql_parserParser::IntervalContext::INTERVAL() {
  return getToken(sql_parserParser::INTERVAL, 0);
}

sql_parserParser::ErrorCapturingMultiUnitsIntervalContext* sql_parserParser::IntervalContext::errorCapturingMultiUnitsInterval() {
  return getRuleContext<sql_parserParser::ErrorCapturingMultiUnitsIntervalContext>(0);
}

sql_parserParser::ErrorCapturingUnitToUnitIntervalContext* sql_parserParser::IntervalContext::errorCapturingUnitToUnitInterval() {
  return getRuleContext<sql_parserParser::ErrorCapturingUnitToUnitIntervalContext>(0);
}


size_t sql_parserParser::IntervalContext::getRuleIndex() const {
  return sql_parserParser::RuleInterval;
}


std::any sql_parserParser::IntervalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitInterval(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::IntervalContext* sql_parserParser::interval() {
  IntervalContext *_localctx = _tracker.createInstance<IntervalContext>(_ctx, getState());
  enterRule(_localctx, 74, sql_parserParser::RuleInterval);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(603);
    match(sql_parserParser::INTERVAL);
    setState(606);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx)) {
    case 1: {
      setState(604);
      errorCapturingMultiUnitsInterval();
      break;
    }

    case 2: {
      setState(605);
      errorCapturingUnitToUnitInterval();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ErrorCapturingMultiUnitsIntervalContext ------------------------------------------------------------------

sql_parserParser::ErrorCapturingMultiUnitsIntervalContext::ErrorCapturingMultiUnitsIntervalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

sql_parserParser::MultiUnitsIntervalContext* sql_parserParser::ErrorCapturingMultiUnitsIntervalContext::multiUnitsInterval() {
  return getRuleContext<sql_parserParser::MultiUnitsIntervalContext>(0);
}

sql_parserParser::UnitToUnitIntervalContext* sql_parserParser::ErrorCapturingMultiUnitsIntervalContext::unitToUnitInterval() {
  return getRuleContext<sql_parserParser::UnitToUnitIntervalContext>(0);
}


size_t sql_parserParser::ErrorCapturingMultiUnitsIntervalContext::getRuleIndex() const {
  return sql_parserParser::RuleErrorCapturingMultiUnitsInterval;
}


std::any sql_parserParser::ErrorCapturingMultiUnitsIntervalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitErrorCapturingMultiUnitsInterval(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::ErrorCapturingMultiUnitsIntervalContext* sql_parserParser::errorCapturingMultiUnitsInterval() {
  ErrorCapturingMultiUnitsIntervalContext *_localctx = _tracker.createInstance<ErrorCapturingMultiUnitsIntervalContext>(_ctx, getState());
  enterRule(_localctx, 76, sql_parserParser::RuleErrorCapturingMultiUnitsInterval);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(608);
    multiUnitsInterval();
    setState(610);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx)) {
    case 1: {
      setState(609);
      unitToUnitInterval();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultiUnitsIntervalContext ------------------------------------------------------------------

sql_parserParser::MultiUnitsIntervalContext::MultiUnitsIntervalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<sql_parserParser::IntervalValueContext *> sql_parserParser::MultiUnitsIntervalContext::intervalValue() {
  return getRuleContexts<sql_parserParser::IntervalValueContext>();
}

sql_parserParser::IntervalValueContext* sql_parserParser::MultiUnitsIntervalContext::intervalValue(size_t i) {
  return getRuleContext<sql_parserParser::IntervalValueContext>(i);
}

std::vector<sql_parserParser::IdentifierContext *> sql_parserParser::MultiUnitsIntervalContext::identifier() {
  return getRuleContexts<sql_parserParser::IdentifierContext>();
}

sql_parserParser::IdentifierContext* sql_parserParser::MultiUnitsIntervalContext::identifier(size_t i) {
  return getRuleContext<sql_parserParser::IdentifierContext>(i);
}


size_t sql_parserParser::MultiUnitsIntervalContext::getRuleIndex() const {
  return sql_parserParser::RuleMultiUnitsInterval;
}


std::any sql_parserParser::MultiUnitsIntervalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitMultiUnitsInterval(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::MultiUnitsIntervalContext* sql_parserParser::multiUnitsInterval() {
  MultiUnitsIntervalContext *_localctx = _tracker.createInstance<MultiUnitsIntervalContext>(_ctx, getState());
  enterRule(_localctx, 78, sql_parserParser::RuleMultiUnitsInterval);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(615); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(612);
              intervalValue();
              setState(613);
              antlrcpp::downCast<MultiUnitsIntervalContext *>(_localctx)->identifierContext = identifier();
              antlrcpp::downCast<MultiUnitsIntervalContext *>(_localctx)->unit.push_back(antlrcpp::downCast<MultiUnitsIntervalContext *>(_localctx)->identifierContext);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(617); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ErrorCapturingUnitToUnitIntervalContext ------------------------------------------------------------------

sql_parserParser::ErrorCapturingUnitToUnitIntervalContext::ErrorCapturingUnitToUnitIntervalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<sql_parserParser::UnitToUnitIntervalContext *> sql_parserParser::ErrorCapturingUnitToUnitIntervalContext::unitToUnitInterval() {
  return getRuleContexts<sql_parserParser::UnitToUnitIntervalContext>();
}

sql_parserParser::UnitToUnitIntervalContext* sql_parserParser::ErrorCapturingUnitToUnitIntervalContext::unitToUnitInterval(size_t i) {
  return getRuleContext<sql_parserParser::UnitToUnitIntervalContext>(i);
}

sql_parserParser::MultiUnitsIntervalContext* sql_parserParser::ErrorCapturingUnitToUnitIntervalContext::multiUnitsInterval() {
  return getRuleContext<sql_parserParser::MultiUnitsIntervalContext>(0);
}


size_t sql_parserParser::ErrorCapturingUnitToUnitIntervalContext::getRuleIndex() const {
  return sql_parserParser::RuleErrorCapturingUnitToUnitInterval;
}


std::any sql_parserParser::ErrorCapturingUnitToUnitIntervalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitErrorCapturingUnitToUnitInterval(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::ErrorCapturingUnitToUnitIntervalContext* sql_parserParser::errorCapturingUnitToUnitInterval() {
  ErrorCapturingUnitToUnitIntervalContext *_localctx = _tracker.createInstance<ErrorCapturingUnitToUnitIntervalContext>(_ctx, getState());
  enterRule(_localctx, 80, sql_parserParser::RuleErrorCapturingUnitToUnitInterval);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(619);
    antlrcpp::downCast<ErrorCapturingUnitToUnitIntervalContext *>(_localctx)->body = unitToUnitInterval();
    setState(622);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx)) {
    case 1: {
      setState(620);
      antlrcpp::downCast<ErrorCapturingUnitToUnitIntervalContext *>(_localctx)->error1 = multiUnitsInterval();
      break;
    }

    case 2: {
      setState(621);
      antlrcpp::downCast<ErrorCapturingUnitToUnitIntervalContext *>(_localctx)->error2 = unitToUnitInterval();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnitToUnitIntervalContext ------------------------------------------------------------------

sql_parserParser::UnitToUnitIntervalContext::UnitToUnitIntervalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* sql_parserParser::UnitToUnitIntervalContext::TO() {
  return getToken(sql_parserParser::TO, 0);
}

sql_parserParser::IntervalValueContext* sql_parserParser::UnitToUnitIntervalContext::intervalValue() {
  return getRuleContext<sql_parserParser::IntervalValueContext>(0);
}

std::vector<sql_parserParser::IdentifierContext *> sql_parserParser::UnitToUnitIntervalContext::identifier() {
  return getRuleContexts<sql_parserParser::IdentifierContext>();
}

sql_parserParser::IdentifierContext* sql_parserParser::UnitToUnitIntervalContext::identifier(size_t i) {
  return getRuleContext<sql_parserParser::IdentifierContext>(i);
}


size_t sql_parserParser::UnitToUnitIntervalContext::getRuleIndex() const {
  return sql_parserParser::RuleUnitToUnitInterval;
}


std::any sql_parserParser::UnitToUnitIntervalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitUnitToUnitInterval(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::UnitToUnitIntervalContext* sql_parserParser::unitToUnitInterval() {
  UnitToUnitIntervalContext *_localctx = _tracker.createInstance<UnitToUnitIntervalContext>(_ctx, getState());
  enterRule(_localctx, 82, sql_parserParser::RuleUnitToUnitInterval);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(624);
    antlrcpp::downCast<UnitToUnitIntervalContext *>(_localctx)->value = intervalValue();
    setState(625);
    antlrcpp::downCast<UnitToUnitIntervalContext *>(_localctx)->from = identifier();
    setState(626);
    match(sql_parserParser::TO);
    setState(627);
    antlrcpp::downCast<UnitToUnitIntervalContext *>(_localctx)->to = identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntervalValueContext ------------------------------------------------------------------

sql_parserParser::IntervalValueContext::IntervalValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* sql_parserParser::IntervalValueContext::INTEGER_VALUE() {
  return getToken(sql_parserParser::INTEGER_VALUE, 0);
}

tree::TerminalNode* sql_parserParser::IntervalValueContext::DECIMAL_VALUE() {
  return getToken(sql_parserParser::DECIMAL_VALUE, 0);
}

tree::TerminalNode* sql_parserParser::IntervalValueContext::PLUS() {
  return getToken(sql_parserParser::PLUS, 0);
}

tree::TerminalNode* sql_parserParser::IntervalValueContext::MINUS() {
  return getToken(sql_parserParser::MINUS, 0);
}

tree::TerminalNode* sql_parserParser::IntervalValueContext::STRING() {
  return getToken(sql_parserParser::STRING, 0);
}


size_t sql_parserParser::IntervalValueContext::getRuleIndex() const {
  return sql_parserParser::RuleIntervalValue;
}


std::any sql_parserParser::IntervalValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitIntervalValue(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::IntervalValueContext* sql_parserParser::intervalValue() {
  IntervalValueContext *_localctx = _tracker.createInstance<IntervalValueContext>(_ctx, getState());
  enterRule(_localctx, 84, sql_parserParser::RuleIntervalValue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(634);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case sql_parserParser::PLUS:
      case sql_parserParser::MINUS:
      case sql_parserParser::INTEGER_VALUE:
      case sql_parserParser::DECIMAL_VALUE: {
        enterOuterAlt(_localctx, 1);
        setState(630);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == sql_parserParser::PLUS

        || _la == sql_parserParser::MINUS) {
          setState(629);
          _la = _input->LA(1);
          if (!(_la == sql_parserParser::PLUS

          || _la == sql_parserParser::MINUS)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        setState(632);
        _la = _input->LA(1);
        if (!(_la == sql_parserParser::INTEGER_VALUE

        || _la == sql_parserParser::DECIMAL_VALUE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case sql_parserParser::STRING: {
        enterOuterAlt(_localctx, 2);
        setState(633);
        match(sql_parserParser::STRING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColPositionContext ------------------------------------------------------------------

sql_parserParser::ColPositionContext::ColPositionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* sql_parserParser::ColPositionContext::FIRST() {
  return getToken(sql_parserParser::FIRST, 0);
}

tree::TerminalNode* sql_parserParser::ColPositionContext::AFTER() {
  return getToken(sql_parserParser::AFTER, 0);
}

sql_parserParser::ErrorCapturingIdentifierContext* sql_parserParser::ColPositionContext::errorCapturingIdentifier() {
  return getRuleContext<sql_parserParser::ErrorCapturingIdentifierContext>(0);
}


size_t sql_parserParser::ColPositionContext::getRuleIndex() const {
  return sql_parserParser::RuleColPosition;
}


std::any sql_parserParser::ColPositionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitColPosition(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::ColPositionContext* sql_parserParser::colPosition() {
  ColPositionContext *_localctx = _tracker.createInstance<ColPositionContext>(_ctx, getState());
  enterRule(_localctx, 86, sql_parserParser::RuleColPosition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(639);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case sql_parserParser::FIRST: {
        enterOuterAlt(_localctx, 1);
        setState(636);
        antlrcpp::downCast<ColPositionContext *>(_localctx)->position = match(sql_parserParser::FIRST);
        break;
      }

      case sql_parserParser::AFTER: {
        enterOuterAlt(_localctx, 2);
        setState(637);
        antlrcpp::downCast<ColPositionContext *>(_localctx)->position = match(sql_parserParser::AFTER);
        setState(638);
        antlrcpp::downCast<ColPositionContext *>(_localctx)->afterCol = errorCapturingIdentifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DataTypeContext ------------------------------------------------------------------

sql_parserParser::DataTypeContext::DataTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t sql_parserParser::DataTypeContext::getRuleIndex() const {
  return sql_parserParser::RuleDataType;
}

void sql_parserParser::DataTypeContext::copyFrom(DataTypeContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- ComplexDataTypeContext ------------------------------------------------------------------

tree::TerminalNode* sql_parserParser::ComplexDataTypeContext::LT() {
  return getToken(sql_parserParser::LT, 0);
}

std::vector<sql_parserParser::DataTypeContext *> sql_parserParser::ComplexDataTypeContext::dataType() {
  return getRuleContexts<sql_parserParser::DataTypeContext>();
}

sql_parserParser::DataTypeContext* sql_parserParser::ComplexDataTypeContext::dataType(size_t i) {
  return getRuleContext<sql_parserParser::DataTypeContext>(i);
}

tree::TerminalNode* sql_parserParser::ComplexDataTypeContext::GT() {
  return getToken(sql_parserParser::GT, 0);
}

tree::TerminalNode* sql_parserParser::ComplexDataTypeContext::ARRAY() {
  return getToken(sql_parserParser::ARRAY, 0);
}

tree::TerminalNode* sql_parserParser::ComplexDataTypeContext::MAP() {
  return getToken(sql_parserParser::MAP, 0);
}

tree::TerminalNode* sql_parserParser::ComplexDataTypeContext::STRUCT() {
  return getToken(sql_parserParser::STRUCT, 0);
}

tree::TerminalNode* sql_parserParser::ComplexDataTypeContext::NEQ() {
  return getToken(sql_parserParser::NEQ, 0);
}

sql_parserParser::ComplexColTypeListContext* sql_parserParser::ComplexDataTypeContext::complexColTypeList() {
  return getRuleContext<sql_parserParser::ComplexColTypeListContext>(0);
}

sql_parserParser::ComplexDataTypeContext::ComplexDataTypeContext(DataTypeContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::ComplexDataTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitComplexDataType(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PrimitiveDataTypeContext ------------------------------------------------------------------

sql_parserParser::IdentifierContext* sql_parserParser::PrimitiveDataTypeContext::identifier() {
  return getRuleContext<sql_parserParser::IdentifierContext>(0);
}

std::vector<tree::TerminalNode *> sql_parserParser::PrimitiveDataTypeContext::INTEGER_VALUE() {
  return getTokens(sql_parserParser::INTEGER_VALUE);
}

tree::TerminalNode* sql_parserParser::PrimitiveDataTypeContext::INTEGER_VALUE(size_t i) {
  return getToken(sql_parserParser::INTEGER_VALUE, i);
}

sql_parserParser::PrimitiveDataTypeContext::PrimitiveDataTypeContext(DataTypeContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::PrimitiveDataTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitPrimitiveDataType(this);
  else
    return visitor->visitChildren(this);
}
sql_parserParser::DataTypeContext* sql_parserParser::dataType() {
  DataTypeContext *_localctx = _tracker.createInstance<DataTypeContext>(_ctx, getState());
  enterRule(_localctx, 88, sql_parserParser::RuleDataType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(675);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 74, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<sql_parserParser::ComplexDataTypeContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(641);
      antlrcpp::downCast<ComplexDataTypeContext *>(_localctx)->complex = match(sql_parserParser::ARRAY);
      setState(642);
      match(sql_parserParser::LT);
      setState(643);
      dataType();
      setState(644);
      match(sql_parserParser::GT);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<sql_parserParser::ComplexDataTypeContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(646);
      antlrcpp::downCast<ComplexDataTypeContext *>(_localctx)->complex = match(sql_parserParser::MAP);
      setState(647);
      match(sql_parserParser::LT);
      setState(648);
      dataType();
      setState(649);
      match(sql_parserParser::T__1);
      setState(650);
      dataType();
      setState(651);
      match(sql_parserParser::GT);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<sql_parserParser::ComplexDataTypeContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(653);
      antlrcpp::downCast<ComplexDataTypeContext *>(_localctx)->complex = match(sql_parserParser::STRUCT);
      setState(660);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case sql_parserParser::LT: {
          setState(654);
          match(sql_parserParser::LT);
          setState(656);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if ((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & -512) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 64)) & -1) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 128)) & -1) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 192)) & -1) != 0) || _la == sql_parserParser::IDENTIFIER

          || _la == sql_parserParser::BACKQUOTED_IDENTIFIER) {
            setState(655);
            complexColTypeList();
          }
          setState(658);
          match(sql_parserParser::GT);
          break;
        }

        case sql_parserParser::NEQ: {
          setState(659);
          match(sql_parserParser::NEQ);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<sql_parserParser::PrimitiveDataTypeContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(662);
      identifier();
      setState(673);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == sql_parserParser::T__2) {
        setState(663);
        match(sql_parserParser::T__2);
        setState(664);
        match(sql_parserParser::INTEGER_VALUE);
        setState(669);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == sql_parserParser::T__1) {
          setState(665);
          match(sql_parserParser::T__1);
          setState(666);
          match(sql_parserParser::INTEGER_VALUE);
          setState(671);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(672);
        match(sql_parserParser::T__3);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiedColTypeWithPositionListContext ------------------------------------------------------------------

sql_parserParser::QualifiedColTypeWithPositionListContext::QualifiedColTypeWithPositionListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<sql_parserParser::QualifiedColTypeWithPositionContext *> sql_parserParser::QualifiedColTypeWithPositionListContext::qualifiedColTypeWithPosition() {
  return getRuleContexts<sql_parserParser::QualifiedColTypeWithPositionContext>();
}

sql_parserParser::QualifiedColTypeWithPositionContext* sql_parserParser::QualifiedColTypeWithPositionListContext::qualifiedColTypeWithPosition(size_t i) {
  return getRuleContext<sql_parserParser::QualifiedColTypeWithPositionContext>(i);
}


size_t sql_parserParser::QualifiedColTypeWithPositionListContext::getRuleIndex() const {
  return sql_parserParser::RuleQualifiedColTypeWithPositionList;
}


std::any sql_parserParser::QualifiedColTypeWithPositionListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitQualifiedColTypeWithPositionList(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::QualifiedColTypeWithPositionListContext* sql_parserParser::qualifiedColTypeWithPositionList() {
  QualifiedColTypeWithPositionListContext *_localctx = _tracker.createInstance<QualifiedColTypeWithPositionListContext>(_ctx, getState());
  enterRule(_localctx, 90, sql_parserParser::RuleQualifiedColTypeWithPositionList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(677);
    qualifiedColTypeWithPosition();
    setState(682);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == sql_parserParser::T__1) {
      setState(678);
      match(sql_parserParser::T__1);
      setState(679);
      qualifiedColTypeWithPosition();
      setState(684);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiedColTypeWithPositionContext ------------------------------------------------------------------

sql_parserParser::QualifiedColTypeWithPositionContext::QualifiedColTypeWithPositionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

sql_parserParser::DataTypeContext* sql_parserParser::QualifiedColTypeWithPositionContext::dataType() {
  return getRuleContext<sql_parserParser::DataTypeContext>(0);
}

sql_parserParser::MultipartIdentifierContext* sql_parserParser::QualifiedColTypeWithPositionContext::multipartIdentifier() {
  return getRuleContext<sql_parserParser::MultipartIdentifierContext>(0);
}

tree::TerminalNode* sql_parserParser::QualifiedColTypeWithPositionContext::NOT() {
  return getToken(sql_parserParser::NOT, 0);
}

tree::TerminalNode* sql_parserParser::QualifiedColTypeWithPositionContext::NULL_() {
  return getToken(sql_parserParser::NULL_, 0);
}

sql_parserParser::CommentSpecContext* sql_parserParser::QualifiedColTypeWithPositionContext::commentSpec() {
  return getRuleContext<sql_parserParser::CommentSpecContext>(0);
}

sql_parserParser::ColPositionContext* sql_parserParser::QualifiedColTypeWithPositionContext::colPosition() {
  return getRuleContext<sql_parserParser::ColPositionContext>(0);
}


size_t sql_parserParser::QualifiedColTypeWithPositionContext::getRuleIndex() const {
  return sql_parserParser::RuleQualifiedColTypeWithPosition;
}


std::any sql_parserParser::QualifiedColTypeWithPositionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitQualifiedColTypeWithPosition(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::QualifiedColTypeWithPositionContext* sql_parserParser::qualifiedColTypeWithPosition() {
  QualifiedColTypeWithPositionContext *_localctx = _tracker.createInstance<QualifiedColTypeWithPositionContext>(_ctx, getState());
  enterRule(_localctx, 92, sql_parserParser::RuleQualifiedColTypeWithPosition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(685);
    antlrcpp::downCast<QualifiedColTypeWithPositionContext *>(_localctx)->name = multipartIdentifier();
    setState(686);
    dataType();
    setState(689);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == sql_parserParser::NOT) {
      setState(687);
      match(sql_parserParser::NOT);
      setState(688);
      match(sql_parserParser::NULL_);
    }
    setState(692);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == sql_parserParser::COMMENT) {
      setState(691);
      commentSpec();
    }
    setState(695);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == sql_parserParser::AFTER || _la == sql_parserParser::FIRST) {
      setState(694);
      colPosition();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColTypeListContext ------------------------------------------------------------------

sql_parserParser::ColTypeListContext::ColTypeListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<sql_parserParser::ColTypeContext *> sql_parserParser::ColTypeListContext::colType() {
  return getRuleContexts<sql_parserParser::ColTypeContext>();
}

sql_parserParser::ColTypeContext* sql_parserParser::ColTypeListContext::colType(size_t i) {
  return getRuleContext<sql_parserParser::ColTypeContext>(i);
}


size_t sql_parserParser::ColTypeListContext::getRuleIndex() const {
  return sql_parserParser::RuleColTypeList;
}


std::any sql_parserParser::ColTypeListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitColTypeList(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::ColTypeListContext* sql_parserParser::colTypeList() {
  ColTypeListContext *_localctx = _tracker.createInstance<ColTypeListContext>(_ctx, getState());
  enterRule(_localctx, 94, sql_parserParser::RuleColTypeList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(697);
    colType();
    setState(702);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == sql_parserParser::T__1) {
      setState(698);
      match(sql_parserParser::T__1);
      setState(699);
      colType();
      setState(704);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColTypeContext ------------------------------------------------------------------

sql_parserParser::ColTypeContext::ColTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

sql_parserParser::DataTypeContext* sql_parserParser::ColTypeContext::dataType() {
  return getRuleContext<sql_parserParser::DataTypeContext>(0);
}

sql_parserParser::ErrorCapturingIdentifierContext* sql_parserParser::ColTypeContext::errorCapturingIdentifier() {
  return getRuleContext<sql_parserParser::ErrorCapturingIdentifierContext>(0);
}

tree::TerminalNode* sql_parserParser::ColTypeContext::NOT() {
  return getToken(sql_parserParser::NOT, 0);
}

tree::TerminalNode* sql_parserParser::ColTypeContext::NULL_() {
  return getToken(sql_parserParser::NULL_, 0);
}

sql_parserParser::CommentSpecContext* sql_parserParser::ColTypeContext::commentSpec() {
  return getRuleContext<sql_parserParser::CommentSpecContext>(0);
}


size_t sql_parserParser::ColTypeContext::getRuleIndex() const {
  return sql_parserParser::RuleColType;
}


std::any sql_parserParser::ColTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitColType(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::ColTypeContext* sql_parserParser::colType() {
  ColTypeContext *_localctx = _tracker.createInstance<ColTypeContext>(_ctx, getState());
  enterRule(_localctx, 96, sql_parserParser::RuleColType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(705);
    antlrcpp::downCast<ColTypeContext *>(_localctx)->colName = errorCapturingIdentifier();
    setState(706);
    dataType();
    setState(709);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == sql_parserParser::NOT) {
      setState(707);
      match(sql_parserParser::NOT);
      setState(708);
      match(sql_parserParser::NULL_);
    }
    setState(712);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == sql_parserParser::COMMENT) {
      setState(711);
      commentSpec();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComplexColTypeListContext ------------------------------------------------------------------

sql_parserParser::ComplexColTypeListContext::ComplexColTypeListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<sql_parserParser::ComplexColTypeContext *> sql_parserParser::ComplexColTypeListContext::complexColType() {
  return getRuleContexts<sql_parserParser::ComplexColTypeContext>();
}

sql_parserParser::ComplexColTypeContext* sql_parserParser::ComplexColTypeListContext::complexColType(size_t i) {
  return getRuleContext<sql_parserParser::ComplexColTypeContext>(i);
}


size_t sql_parserParser::ComplexColTypeListContext::getRuleIndex() const {
  return sql_parserParser::RuleComplexColTypeList;
}


std::any sql_parserParser::ComplexColTypeListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitComplexColTypeList(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::ComplexColTypeListContext* sql_parserParser::complexColTypeList() {
  ComplexColTypeListContext *_localctx = _tracker.createInstance<ComplexColTypeListContext>(_ctx, getState());
  enterRule(_localctx, 98, sql_parserParser::RuleComplexColTypeList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(714);
    complexColType();
    setState(719);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == sql_parserParser::T__1) {
      setState(715);
      match(sql_parserParser::T__1);
      setState(716);
      complexColType();
      setState(721);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComplexColTypeContext ------------------------------------------------------------------

sql_parserParser::ComplexColTypeContext::ComplexColTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

sql_parserParser::IdentifierContext* sql_parserParser::ComplexColTypeContext::identifier() {
  return getRuleContext<sql_parserParser::IdentifierContext>(0);
}

sql_parserParser::DataTypeContext* sql_parserParser::ComplexColTypeContext::dataType() {
  return getRuleContext<sql_parserParser::DataTypeContext>(0);
}

tree::TerminalNode* sql_parserParser::ComplexColTypeContext::NOT() {
  return getToken(sql_parserParser::NOT, 0);
}

tree::TerminalNode* sql_parserParser::ComplexColTypeContext::NULL_() {
  return getToken(sql_parserParser::NULL_, 0);
}

sql_parserParser::CommentSpecContext* sql_parserParser::ComplexColTypeContext::commentSpec() {
  return getRuleContext<sql_parserParser::CommentSpecContext>(0);
}


size_t sql_parserParser::ComplexColTypeContext::getRuleIndex() const {
  return sql_parserParser::RuleComplexColType;
}


std::any sql_parserParser::ComplexColTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitComplexColType(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::ComplexColTypeContext* sql_parserParser::complexColType() {
  ComplexColTypeContext *_localctx = _tracker.createInstance<ComplexColTypeContext>(_ctx, getState());
  enterRule(_localctx, 100, sql_parserParser::RuleComplexColType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(722);
    identifier();
    setState(723);
    match(sql_parserParser::T__7);
    setState(724);
    dataType();
    setState(727);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == sql_parserParser::NOT) {
      setState(725);
      match(sql_parserParser::NOT);
      setState(726);
      match(sql_parserParser::NULL_);
    }
    setState(730);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == sql_parserParser::COMMENT) {
      setState(729);
      commentSpec();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhenClauseContext ------------------------------------------------------------------

sql_parserParser::WhenClauseContext::WhenClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* sql_parserParser::WhenClauseContext::WHEN() {
  return getToken(sql_parserParser::WHEN, 0);
}

tree::TerminalNode* sql_parserParser::WhenClauseContext::THEN() {
  return getToken(sql_parserParser::THEN, 0);
}

std::vector<sql_parserParser::ExpressionContext *> sql_parserParser::WhenClauseContext::expression() {
  return getRuleContexts<sql_parserParser::ExpressionContext>();
}

sql_parserParser::ExpressionContext* sql_parserParser::WhenClauseContext::expression(size_t i) {
  return getRuleContext<sql_parserParser::ExpressionContext>(i);
}


size_t sql_parserParser::WhenClauseContext::getRuleIndex() const {
  return sql_parserParser::RuleWhenClause;
}


std::any sql_parserParser::WhenClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitWhenClause(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::WhenClauseContext* sql_parserParser::whenClause() {
  WhenClauseContext *_localctx = _tracker.createInstance<WhenClauseContext>(_ctx, getState());
  enterRule(_localctx, 102, sql_parserParser::RuleWhenClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(732);
    match(sql_parserParser::WHEN);
    setState(733);
    antlrcpp::downCast<WhenClauseContext *>(_localctx)->condition = expression();
    setState(734);
    match(sql_parserParser::THEN);
    setState(735);
    antlrcpp::downCast<WhenClauseContext *>(_localctx)->result = expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowClauseContext ------------------------------------------------------------------

sql_parserParser::WindowClauseContext::WindowClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* sql_parserParser::WindowClauseContext::WINDOW() {
  return getToken(sql_parserParser::WINDOW, 0);
}

std::vector<sql_parserParser::NamedWindowContext *> sql_parserParser::WindowClauseContext::namedWindow() {
  return getRuleContexts<sql_parserParser::NamedWindowContext>();
}

sql_parserParser::NamedWindowContext* sql_parserParser::WindowClauseContext::namedWindow(size_t i) {
  return getRuleContext<sql_parserParser::NamedWindowContext>(i);
}


size_t sql_parserParser::WindowClauseContext::getRuleIndex() const {
  return sql_parserParser::RuleWindowClause;
}


std::any sql_parserParser::WindowClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitWindowClause(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::WindowClauseContext* sql_parserParser::windowClause() {
  WindowClauseContext *_localctx = _tracker.createInstance<WindowClauseContext>(_ctx, getState());
  enterRule(_localctx, 104, sql_parserParser::RuleWindowClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(737);
    match(sql_parserParser::WINDOW);
    setState(738);
    namedWindow();
    setState(743);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == sql_parserParser::T__1) {
      setState(739);
      match(sql_parserParser::T__1);
      setState(740);
      namedWindow();
      setState(745);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamedWindowContext ------------------------------------------------------------------

sql_parserParser::NamedWindowContext::NamedWindowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* sql_parserParser::NamedWindowContext::AS() {
  return getToken(sql_parserParser::AS, 0);
}

sql_parserParser::WindowSpecContext* sql_parserParser::NamedWindowContext::windowSpec() {
  return getRuleContext<sql_parserParser::WindowSpecContext>(0);
}

sql_parserParser::ErrorCapturingIdentifierContext* sql_parserParser::NamedWindowContext::errorCapturingIdentifier() {
  return getRuleContext<sql_parserParser::ErrorCapturingIdentifierContext>(0);
}


size_t sql_parserParser::NamedWindowContext::getRuleIndex() const {
  return sql_parserParser::RuleNamedWindow;
}


std::any sql_parserParser::NamedWindowContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitNamedWindow(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::NamedWindowContext* sql_parserParser::namedWindow() {
  NamedWindowContext *_localctx = _tracker.createInstance<NamedWindowContext>(_ctx, getState());
  enterRule(_localctx, 106, sql_parserParser::RuleNamedWindow);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(746);
    antlrcpp::downCast<NamedWindowContext *>(_localctx)->name = errorCapturingIdentifier();
    setState(747);
    match(sql_parserParser::AS);
    setState(748);
    windowSpec();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowSpecContext ------------------------------------------------------------------

sql_parserParser::WindowSpecContext::WindowSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t sql_parserParser::WindowSpecContext::getRuleIndex() const {
  return sql_parserParser::RuleWindowSpec;
}

void sql_parserParser::WindowSpecContext::copyFrom(WindowSpecContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- WindowRefContext ------------------------------------------------------------------

sql_parserParser::ErrorCapturingIdentifierContext* sql_parserParser::WindowRefContext::errorCapturingIdentifier() {
  return getRuleContext<sql_parserParser::ErrorCapturingIdentifierContext>(0);
}

sql_parserParser::WindowRefContext::WindowRefContext(WindowSpecContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::WindowRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitWindowRef(this);
  else
    return visitor->visitChildren(this);
}
//----------------- WindowDefContext ------------------------------------------------------------------

tree::TerminalNode* sql_parserParser::WindowDefContext::CLUSTER() {
  return getToken(sql_parserParser::CLUSTER, 0);
}

std::vector<tree::TerminalNode *> sql_parserParser::WindowDefContext::BY() {
  return getTokens(sql_parserParser::BY);
}

tree::TerminalNode* sql_parserParser::WindowDefContext::BY(size_t i) {
  return getToken(sql_parserParser::BY, i);
}

std::vector<sql_parserParser::ExpressionContext *> sql_parserParser::WindowDefContext::expression() {
  return getRuleContexts<sql_parserParser::ExpressionContext>();
}

sql_parserParser::ExpressionContext* sql_parserParser::WindowDefContext::expression(size_t i) {
  return getRuleContext<sql_parserParser::ExpressionContext>(i);
}

sql_parserParser::WindowFrameContext* sql_parserParser::WindowDefContext::windowFrame() {
  return getRuleContext<sql_parserParser::WindowFrameContext>(0);
}

std::vector<sql_parserParser::SortItemContext *> sql_parserParser::WindowDefContext::sortItem() {
  return getRuleContexts<sql_parserParser::SortItemContext>();
}

sql_parserParser::SortItemContext* sql_parserParser::WindowDefContext::sortItem(size_t i) {
  return getRuleContext<sql_parserParser::SortItemContext>(i);
}

tree::TerminalNode* sql_parserParser::WindowDefContext::PARTITION() {
  return getToken(sql_parserParser::PARTITION, 0);
}

tree::TerminalNode* sql_parserParser::WindowDefContext::DISTRIBUTE() {
  return getToken(sql_parserParser::DISTRIBUTE, 0);
}

tree::TerminalNode* sql_parserParser::WindowDefContext::ORDER() {
  return getToken(sql_parserParser::ORDER, 0);
}

tree::TerminalNode* sql_parserParser::WindowDefContext::SORT() {
  return getToken(sql_parserParser::SORT, 0);
}

sql_parserParser::WindowDefContext::WindowDefContext(WindowSpecContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::WindowDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitWindowDef(this);
  else
    return visitor->visitChildren(this);
}
sql_parserParser::WindowSpecContext* sql_parserParser::windowSpec() {
  WindowSpecContext *_localctx = _tracker.createInstance<WindowSpecContext>(_ctx, getState());
  enterRule(_localctx, 108, sql_parserParser::RuleWindowSpec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(796);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 93, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<sql_parserParser::WindowRefContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(750);
      antlrcpp::downCast<WindowRefContext *>(_localctx)->name = errorCapturingIdentifier();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<sql_parserParser::WindowRefContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(751);
      match(sql_parserParser::T__2);
      setState(752);
      antlrcpp::downCast<WindowRefContext *>(_localctx)->name = errorCapturingIdentifier();
      setState(753);
      match(sql_parserParser::T__3);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<sql_parserParser::WindowDefContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(755);
      match(sql_parserParser::T__2);
      setState(790);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case sql_parserParser::CLUSTER: {
          setState(756);
          match(sql_parserParser::CLUSTER);
          setState(757);
          match(sql_parserParser::BY);
          setState(758);
          antlrcpp::downCast<WindowDefContext *>(_localctx)->expressionContext = expression();
          antlrcpp::downCast<WindowDefContext *>(_localctx)->partition.push_back(antlrcpp::downCast<WindowDefContext *>(_localctx)->expressionContext);
          setState(763);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == sql_parserParser::T__1) {
            setState(759);
            match(sql_parserParser::T__1);
            setState(760);
            antlrcpp::downCast<WindowDefContext *>(_localctx)->expressionContext = expression();
            antlrcpp::downCast<WindowDefContext *>(_localctx)->partition.push_back(antlrcpp::downCast<WindowDefContext *>(_localctx)->expressionContext);
            setState(765);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          break;
        }

        case sql_parserParser::T__3:
        case sql_parserParser::DISTRIBUTE:
        case sql_parserParser::ORDER:
        case sql_parserParser::PARTITION:
        case sql_parserParser::RANGE:
        case sql_parserParser::ROWS:
        case sql_parserParser::SORT: {
          setState(776);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == sql_parserParser::DISTRIBUTE || _la == sql_parserParser::PARTITION) {
            setState(766);
            _la = _input->LA(1);
            if (!(_la == sql_parserParser::DISTRIBUTE || _la == sql_parserParser::PARTITION)) {
            _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              consume();
            }
            setState(767);
            match(sql_parserParser::BY);
            setState(768);
            antlrcpp::downCast<WindowDefContext *>(_localctx)->expressionContext = expression();
            antlrcpp::downCast<WindowDefContext *>(_localctx)->partition.push_back(antlrcpp::downCast<WindowDefContext *>(_localctx)->expressionContext);
            setState(773);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while (_la == sql_parserParser::T__1) {
              setState(769);
              match(sql_parserParser::T__1);
              setState(770);
              antlrcpp::downCast<WindowDefContext *>(_localctx)->expressionContext = expression();
              antlrcpp::downCast<WindowDefContext *>(_localctx)->partition.push_back(antlrcpp::downCast<WindowDefContext *>(_localctx)->expressionContext);
              setState(775);
              _errHandler->sync(this);
              _la = _input->LA(1);
            }
          }
          setState(788);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == sql_parserParser::ORDER

          || _la == sql_parserParser::SORT) {
            setState(778);
            _la = _input->LA(1);
            if (!(_la == sql_parserParser::ORDER

            || _la == sql_parserParser::SORT)) {
            _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              consume();
            }
            setState(779);
            match(sql_parserParser::BY);
            setState(780);
            sortItem();
            setState(785);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while (_la == sql_parserParser::T__1) {
              setState(781);
              match(sql_parserParser::T__1);
              setState(782);
              sortItem();
              setState(787);
              _errHandler->sync(this);
              _la = _input->LA(1);
            }
          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(793);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == sql_parserParser::RANGE

      || _la == sql_parserParser::ROWS) {
        setState(792);
        windowFrame();
      }
      setState(795);
      match(sql_parserParser::T__3);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFrameContext ------------------------------------------------------------------

sql_parserParser::WindowFrameContext::WindowFrameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* sql_parserParser::WindowFrameContext::RANGE() {
  return getToken(sql_parserParser::RANGE, 0);
}

std::vector<sql_parserParser::FrameBoundContext *> sql_parserParser::WindowFrameContext::frameBound() {
  return getRuleContexts<sql_parserParser::FrameBoundContext>();
}

sql_parserParser::FrameBoundContext* sql_parserParser::WindowFrameContext::frameBound(size_t i) {
  return getRuleContext<sql_parserParser::FrameBoundContext>(i);
}

tree::TerminalNode* sql_parserParser::WindowFrameContext::ROWS() {
  return getToken(sql_parserParser::ROWS, 0);
}

tree::TerminalNode* sql_parserParser::WindowFrameContext::BETWEEN() {
  return getToken(sql_parserParser::BETWEEN, 0);
}

tree::TerminalNode* sql_parserParser::WindowFrameContext::AND() {
  return getToken(sql_parserParser::AND, 0);
}


size_t sql_parserParser::WindowFrameContext::getRuleIndex() const {
  return sql_parserParser::RuleWindowFrame;
}


std::any sql_parserParser::WindowFrameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitWindowFrame(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::WindowFrameContext* sql_parserParser::windowFrame() {
  WindowFrameContext *_localctx = _tracker.createInstance<WindowFrameContext>(_ctx, getState());
  enterRule(_localctx, 110, sql_parserParser::RuleWindowFrame);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(814);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 94, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(798);
      antlrcpp::downCast<WindowFrameContext *>(_localctx)->frameType = match(sql_parserParser::RANGE);
      setState(799);
      antlrcpp::downCast<WindowFrameContext *>(_localctx)->start = frameBound();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(800);
      antlrcpp::downCast<WindowFrameContext *>(_localctx)->frameType = match(sql_parserParser::ROWS);
      setState(801);
      antlrcpp::downCast<WindowFrameContext *>(_localctx)->start = frameBound();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(802);
      antlrcpp::downCast<WindowFrameContext *>(_localctx)->frameType = match(sql_parserParser::RANGE);
      setState(803);
      match(sql_parserParser::BETWEEN);
      setState(804);
      antlrcpp::downCast<WindowFrameContext *>(_localctx)->start = frameBound();
      setState(805);
      match(sql_parserParser::AND);
      setState(806);
      antlrcpp::downCast<WindowFrameContext *>(_localctx)->end = frameBound();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(808);
      antlrcpp::downCast<WindowFrameContext *>(_localctx)->frameType = match(sql_parserParser::ROWS);
      setState(809);
      match(sql_parserParser::BETWEEN);
      setState(810);
      antlrcpp::downCast<WindowFrameContext *>(_localctx)->start = frameBound();
      setState(811);
      match(sql_parserParser::AND);
      setState(812);
      antlrcpp::downCast<WindowFrameContext *>(_localctx)->end = frameBound();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FrameBoundContext ------------------------------------------------------------------

sql_parserParser::FrameBoundContext::FrameBoundContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* sql_parserParser::FrameBoundContext::UNBOUNDED() {
  return getToken(sql_parserParser::UNBOUNDED, 0);
}

tree::TerminalNode* sql_parserParser::FrameBoundContext::PRECEDING() {
  return getToken(sql_parserParser::PRECEDING, 0);
}

tree::TerminalNode* sql_parserParser::FrameBoundContext::FOLLOWING() {
  return getToken(sql_parserParser::FOLLOWING, 0);
}

tree::TerminalNode* sql_parserParser::FrameBoundContext::ROW() {
  return getToken(sql_parserParser::ROW, 0);
}

tree::TerminalNode* sql_parserParser::FrameBoundContext::CURRENT() {
  return getToken(sql_parserParser::CURRENT, 0);
}

sql_parserParser::ExpressionContext* sql_parserParser::FrameBoundContext::expression() {
  return getRuleContext<sql_parserParser::ExpressionContext>(0);
}


size_t sql_parserParser::FrameBoundContext::getRuleIndex() const {
  return sql_parserParser::RuleFrameBound;
}


std::any sql_parserParser::FrameBoundContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitFrameBound(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::FrameBoundContext* sql_parserParser::frameBound() {
  FrameBoundContext *_localctx = _tracker.createInstance<FrameBoundContext>(_ctx, getState());
  enterRule(_localctx, 112, sql_parserParser::RuleFrameBound);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(823);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 95, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(816);
      match(sql_parserParser::UNBOUNDED);
      setState(817);
      antlrcpp::downCast<FrameBoundContext *>(_localctx)->boundType = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == sql_parserParser::FOLLOWING || _la == sql_parserParser::PRECEDING)) {
        antlrcpp::downCast<FrameBoundContext *>(_localctx)->boundType = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(818);
      antlrcpp::downCast<FrameBoundContext *>(_localctx)->boundType = match(sql_parserParser::CURRENT);
      setState(819);
      match(sql_parserParser::ROW);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(820);
      expression();
      setState(821);
      antlrcpp::downCast<FrameBoundContext *>(_localctx)->boundType = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == sql_parserParser::FOLLOWING || _la == sql_parserParser::PRECEDING)) {
        antlrcpp::downCast<FrameBoundContext *>(_localctx)->boundType = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiedNameListContext ------------------------------------------------------------------

sql_parserParser::QualifiedNameListContext::QualifiedNameListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<sql_parserParser::QualifiedNameContext *> sql_parserParser::QualifiedNameListContext::qualifiedName() {
  return getRuleContexts<sql_parserParser::QualifiedNameContext>();
}

sql_parserParser::QualifiedNameContext* sql_parserParser::QualifiedNameListContext::qualifiedName(size_t i) {
  return getRuleContext<sql_parserParser::QualifiedNameContext>(i);
}


size_t sql_parserParser::QualifiedNameListContext::getRuleIndex() const {
  return sql_parserParser::RuleQualifiedNameList;
}


std::any sql_parserParser::QualifiedNameListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitQualifiedNameList(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::QualifiedNameListContext* sql_parserParser::qualifiedNameList() {
  QualifiedNameListContext *_localctx = _tracker.createInstance<QualifiedNameListContext>(_ctx, getState());
  enterRule(_localctx, 114, sql_parserParser::RuleQualifiedNameList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(825);
    qualifiedName();
    setState(830);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == sql_parserParser::T__1) {
      setState(826);
      match(sql_parserParser::T__1);
      setState(827);
      qualifiedName();
      setState(832);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionNameContext ------------------------------------------------------------------

sql_parserParser::FunctionNameContext::FunctionNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

sql_parserParser::QualifiedNameContext* sql_parserParser::FunctionNameContext::qualifiedName() {
  return getRuleContext<sql_parserParser::QualifiedNameContext>(0);
}

tree::TerminalNode* sql_parserParser::FunctionNameContext::FILTER() {
  return getToken(sql_parserParser::FILTER, 0);
}

tree::TerminalNode* sql_parserParser::FunctionNameContext::LEFT() {
  return getToken(sql_parserParser::LEFT, 0);
}

tree::TerminalNode* sql_parserParser::FunctionNameContext::RIGHT() {
  return getToken(sql_parserParser::RIGHT, 0);
}


size_t sql_parserParser::FunctionNameContext::getRuleIndex() const {
  return sql_parserParser::RuleFunctionName;
}


std::any sql_parserParser::FunctionNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitFunctionName(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::FunctionNameContext* sql_parserParser::functionName() {
  FunctionNameContext *_localctx = _tracker.createInstance<FunctionNameContext>(_ctx, getState());
  enterRule(_localctx, 116, sql_parserParser::RuleFunctionName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(837);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 97, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(833);
      qualifiedName();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(834);
      match(sql_parserParser::FILTER);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(835);
      match(sql_parserParser::LEFT);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(836);
      match(sql_parserParser::RIGHT);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiedNameContext ------------------------------------------------------------------

sql_parserParser::QualifiedNameContext::QualifiedNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<sql_parserParser::IdentifierContext *> sql_parserParser::QualifiedNameContext::identifier() {
  return getRuleContexts<sql_parserParser::IdentifierContext>();
}

sql_parserParser::IdentifierContext* sql_parserParser::QualifiedNameContext::identifier(size_t i) {
  return getRuleContext<sql_parserParser::IdentifierContext>(i);
}


size_t sql_parserParser::QualifiedNameContext::getRuleIndex() const {
  return sql_parserParser::RuleQualifiedName;
}


std::any sql_parserParser::QualifiedNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitQualifiedName(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::QualifiedNameContext* sql_parserParser::qualifiedName() {
  QualifiedNameContext *_localctx = _tracker.createInstance<QualifiedNameContext>(_ctx, getState());
  enterRule(_localctx, 118, sql_parserParser::RuleQualifiedName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(839);
    identifier();
    setState(844);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(840);
        match(sql_parserParser::T__4);
        setState(841);
        identifier(); 
      }
      setState(846);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ErrorCapturingIdentifierContext ------------------------------------------------------------------

sql_parserParser::ErrorCapturingIdentifierContext::ErrorCapturingIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

sql_parserParser::IdentifierContext* sql_parserParser::ErrorCapturingIdentifierContext::identifier() {
  return getRuleContext<sql_parserParser::IdentifierContext>(0);
}

sql_parserParser::ErrorCapturingIdentifierExtraContext* sql_parserParser::ErrorCapturingIdentifierContext::errorCapturingIdentifierExtra() {
  return getRuleContext<sql_parserParser::ErrorCapturingIdentifierExtraContext>(0);
}


size_t sql_parserParser::ErrorCapturingIdentifierContext::getRuleIndex() const {
  return sql_parserParser::RuleErrorCapturingIdentifier;
}


std::any sql_parserParser::ErrorCapturingIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitErrorCapturingIdentifier(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::ErrorCapturingIdentifierContext* sql_parserParser::errorCapturingIdentifier() {
  ErrorCapturingIdentifierContext *_localctx = _tracker.createInstance<ErrorCapturingIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 120, sql_parserParser::RuleErrorCapturingIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(847);
    identifier();
    setState(848);
    errorCapturingIdentifierExtra();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ErrorCapturingIdentifierExtraContext ------------------------------------------------------------------

sql_parserParser::ErrorCapturingIdentifierExtraContext::ErrorCapturingIdentifierExtraContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t sql_parserParser::ErrorCapturingIdentifierExtraContext::getRuleIndex() const {
  return sql_parserParser::RuleErrorCapturingIdentifierExtra;
}

void sql_parserParser::ErrorCapturingIdentifierExtraContext::copyFrom(ErrorCapturingIdentifierExtraContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- ErrorIdentContext ------------------------------------------------------------------

std::vector<tree::TerminalNode *> sql_parserParser::ErrorIdentContext::MINUS() {
  return getTokens(sql_parserParser::MINUS);
}

tree::TerminalNode* sql_parserParser::ErrorIdentContext::MINUS(size_t i) {
  return getToken(sql_parserParser::MINUS, i);
}

std::vector<sql_parserParser::IdentifierContext *> sql_parserParser::ErrorIdentContext::identifier() {
  return getRuleContexts<sql_parserParser::IdentifierContext>();
}

sql_parserParser::IdentifierContext* sql_parserParser::ErrorIdentContext::identifier(size_t i) {
  return getRuleContext<sql_parserParser::IdentifierContext>(i);
}

sql_parserParser::ErrorIdentContext::ErrorIdentContext(ErrorCapturingIdentifierExtraContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::ErrorIdentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitErrorIdent(this);
  else
    return visitor->visitChildren(this);
}
//----------------- RealIdentContext ------------------------------------------------------------------

sql_parserParser::RealIdentContext::RealIdentContext(ErrorCapturingIdentifierExtraContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::RealIdentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitRealIdent(this);
  else
    return visitor->visitChildren(this);
}
sql_parserParser::ErrorCapturingIdentifierExtraContext* sql_parserParser::errorCapturingIdentifierExtra() {
  ErrorCapturingIdentifierExtraContext *_localctx = _tracker.createInstance<ErrorCapturingIdentifierExtraContext>(_ctx, getState());
  enterRule(_localctx, 122, sql_parserParser::RuleErrorCapturingIdentifierExtra);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(857);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case sql_parserParser::MINUS: {
        _localctx = _tracker.createInstance<sql_parserParser::ErrorIdentContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(852); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(850);
          match(sql_parserParser::MINUS);
          setState(851);
          identifier();
          setState(854); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == sql_parserParser::MINUS);
        break;
      }

      case sql_parserParser::EOF:
      case sql_parserParser::T__0:
      case sql_parserParser::T__1:
      case sql_parserParser::T__3:
      case sql_parserParser::T__4:
      case sql_parserParser::ADD:
      case sql_parserParser::AFTER:
      case sql_parserParser::ALL:
      case sql_parserParser::ALTER:
      case sql_parserParser::ANALYZE:
      case sql_parserParser::AND:
      case sql_parserParser::ANTI:
      case sql_parserParser::ANY:
      case sql_parserParser::ARCHIVE:
      case sql_parserParser::ARRAY:
      case sql_parserParser::AS:
      case sql_parserParser::ASC:
      case sql_parserParser::AT:
      case sql_parserParser::AUTHORIZATION:
      case sql_parserParser::BETWEEN:
      case sql_parserParser::BOTH:
      case sql_parserParser::BUCKET:
      case sql_parserParser::BUCKETS:
      case sql_parserParser::BY:
      case sql_parserParser::CACHE:
      case sql_parserParser::CASCADE:
      case sql_parserParser::CASE:
      case sql_parserParser::CAST:
      case sql_parserParser::CHANGE:
      case sql_parserParser::CHECK:
      case sql_parserParser::CLEAR:
      case sql_parserParser::CLUSTER:
      case sql_parserParser::CLUSTERED:
      case sql_parserParser::CODEGEN:
      case sql_parserParser::COLLATE:
      case sql_parserParser::COLLECTION:
      case sql_parserParser::COLUMN:
      case sql_parserParser::COLUMNS:
      case sql_parserParser::COMMENT:
      case sql_parserParser::COMMIT:
      case sql_parserParser::COMPACT:
      case sql_parserParser::COMPACTIONS:
      case sql_parserParser::COMPUTE:
      case sql_parserParser::CONCATENATE:
      case sql_parserParser::CONSTRAINT:
      case sql_parserParser::COST:
      case sql_parserParser::CREATE:
      case sql_parserParser::CROSS:
      case sql_parserParser::CUBE:
      case sql_parserParser::CURRENT:
      case sql_parserParser::CURRENT_DATE:
      case sql_parserParser::CURRENT_TIME:
      case sql_parserParser::CURRENT_TIMESTAMP:
      case sql_parserParser::CURRENT_USER:
      case sql_parserParser::DATA:
      case sql_parserParser::DATABASE:
      case sql_parserParser::DATABASES:
      case sql_parserParser::DBPROPERTIES:
      case sql_parserParser::DEFINED:
      case sql_parserParser::DELETE:
      case sql_parserParser::DELIMITED:
      case sql_parserParser::DESC:
      case sql_parserParser::DESCRIBE:
      case sql_parserParser::DFS:
      case sql_parserParser::DIRECTORIES:
      case sql_parserParser::DIRECTORY:
      case sql_parserParser::DISTINCT:
      case sql_parserParser::DISTRIBUTE:
      case sql_parserParser::DIV:
      case sql_parserParser::DROP:
      case sql_parserParser::ELSE:
      case sql_parserParser::END:
      case sql_parserParser::ESCAPE:
      case sql_parserParser::ESCAPED:
      case sql_parserParser::EXCEPT:
      case sql_parserParser::EXCHANGE:
      case sql_parserParser::EXISTS:
      case sql_parserParser::EXPLAIN:
      case sql_parserParser::EXPORT:
      case sql_parserParser::EXTENDED:
      case sql_parserParser::EXTERNAL:
      case sql_parserParser::EXTRACT:
      case sql_parserParser::FALSE:
      case sql_parserParser::FETCH:
      case sql_parserParser::FIELDS:
      case sql_parserParser::FILTER:
      case sql_parserParser::FILEFORMAT:
      case sql_parserParser::FIRST:
      case sql_parserParser::FOLLOWING:
      case sql_parserParser::FOR:
      case sql_parserParser::FOREIGN:
      case sql_parserParser::FORMAT:
      case sql_parserParser::FORMATTED:
      case sql_parserParser::FROM:
      case sql_parserParser::FULL:
      case sql_parserParser::FUNCTION:
      case sql_parserParser::FUNCTIONS:
      case sql_parserParser::GLOBAL:
      case sql_parserParser::GRANT:
      case sql_parserParser::GROUP:
      case sql_parserParser::GROUPING:
      case sql_parserParser::HAVING:
      case sql_parserParser::IF:
      case sql_parserParser::IGNORE:
      case sql_parserParser::IMPORT:
      case sql_parserParser::IN:
      case sql_parserParser::INDEX:
      case sql_parserParser::INDEXES:
      case sql_parserParser::INNER:
      case sql_parserParser::INPATH:
      case sql_parserParser::INPUTFORMAT:
      case sql_parserParser::INSERT:
      case sql_parserParser::INTERSECT:
      case sql_parserParser::INTERVAL:
      case sql_parserParser::INTO:
      case sql_parserParser::IS:
      case sql_parserParser::ITEMS:
      case sql_parserParser::JOIN:
      case sql_parserParser::KEYS:
      case sql_parserParser::LAST:
      case sql_parserParser::LATERAL:
      case sql_parserParser::LAZY:
      case sql_parserParser::LEADING:
      case sql_parserParser::LEFT:
      case sql_parserParser::LIKE:
      case sql_parserParser::LIMIT:
      case sql_parserParser::LINES:
      case sql_parserParser::LIST:
      case sql_parserParser::LOAD:
      case sql_parserParser::LOCAL:
      case sql_parserParser::LOCATION:
      case sql_parserParser::LOCK:
      case sql_parserParser::LOCKS:
      case sql_parserParser::LOGICAL:
      case sql_parserParser::MACRO:
      case sql_parserParser::MAP:
      case sql_parserParser::MATCHED:
      case sql_parserParser::MERGE:
      case sql_parserParser::MSCK:
      case sql_parserParser::NAMESPACE:
      case sql_parserParser::NAMESPACES:
      case sql_parserParser::NATURAL:
      case sql_parserParser::NO:
      case sql_parserParser::NOT:
      case sql_parserParser::NULL_:
      case sql_parserParser::NULLS:
      case sql_parserParser::OF:
      case sql_parserParser::ON:
      case sql_parserParser::ONLY:
      case sql_parserParser::OPTION:
      case sql_parserParser::OPTIONS:
      case sql_parserParser::OR:
      case sql_parserParser::ORDER:
      case sql_parserParser::OUT:
      case sql_parserParser::OUTER:
      case sql_parserParser::OUTPUTFORMAT:
      case sql_parserParser::OVER:
      case sql_parserParser::OVERLAPS:
      case sql_parserParser::OVERLAY:
      case sql_parserParser::OVERWRITE:
      case sql_parserParser::PARTITION:
      case sql_parserParser::PARTITIONED:
      case sql_parserParser::PARTITIONS:
      case sql_parserParser::PERCENTLIT:
      case sql_parserParser::PIVOT:
      case sql_parserParser::PLACING:
      case sql_parserParser::POSITION:
      case sql_parserParser::PRECEDING:
      case sql_parserParser::PRIMARY:
      case sql_parserParser::PRINCIPALS:
      case sql_parserParser::PROPERTIES:
      case sql_parserParser::PURGE:
      case sql_parserParser::QUERY:
      case sql_parserParser::RANGE:
      case sql_parserParser::RECORDREADER:
      case sql_parserParser::RECORDWRITER:
      case sql_parserParser::RECOVER:
      case sql_parserParser::REDUCE:
      case sql_parserParser::REFERENCES:
      case sql_parserParser::REFRESH:
      case sql_parserParser::RENAME:
      case sql_parserParser::REPAIR:
      case sql_parserParser::REPLACE:
      case sql_parserParser::RESET:
      case sql_parserParser::RESTRICT:
      case sql_parserParser::REVOKE:
      case sql_parserParser::RIGHT:
      case sql_parserParser::RLIKE:
      case sql_parserParser::ROLE:
      case sql_parserParser::ROLES:
      case sql_parserParser::ROLLBACK:
      case sql_parserParser::ROLLUP:
      case sql_parserParser::ROW:
      case sql_parserParser::ROWS:
      case sql_parserParser::SCHEMA:
      case sql_parserParser::SELECT:
      case sql_parserParser::SEMI:
      case sql_parserParser::SEPARATED:
      case sql_parserParser::SERDE:
      case sql_parserParser::SERDEPROPERTIES:
      case sql_parserParser::SESSION_USER:
      case sql_parserParser::SET:
      case sql_parserParser::SETMINUS:
      case sql_parserParser::SETS:
      case sql_parserParser::SHOW:
      case sql_parserParser::SKEWED:
      case sql_parserParser::SOME:
      case sql_parserParser::SORT:
      case sql_parserParser::SORTED:
      case sql_parserParser::START:
      case sql_parserParser::STATISTICS:
      case sql_parserParser::STORED:
      case sql_parserParser::STRATIFY:
      case sql_parserParser::STRUCT:
      case sql_parserParser::SUBSTR:
      case sql_parserParser::SUBSTRING:
      case sql_parserParser::TABLE:
      case sql_parserParser::TABLES:
      case sql_parserParser::TABLESAMPLE:
      case sql_parserParser::TBLPROPERTIES:
      case sql_parserParser::TEMPORARY:
      case sql_parserParser::TERMINATED:
      case sql_parserParser::THEN:
      case sql_parserParser::TO:
      case sql_parserParser::TOUCH:
      case sql_parserParser::TRAILING:
      case sql_parserParser::TRANSACTION:
      case sql_parserParser::TRANSACTIONS:
      case sql_parserParser::TRANSFORM:
      case sql_parserParser::TRIM:
      case sql_parserParser::TRUE:
      case sql_parserParser::TRUNCATE:
      case sql_parserParser::TYPE:
      case sql_parserParser::UNARCHIVE:
      case sql_parserParser::UNBOUNDED:
      case sql_parserParser::UNCACHE:
      case sql_parserParser::UNION:
      case sql_parserParser::UNIQUE:
      case sql_parserParser::UNKNOWN:
      case sql_parserParser::UNLOCK:
      case sql_parserParser::UNSET:
      case sql_parserParser::UPDATE:
      case sql_parserParser::USE:
      case sql_parserParser::USER:
      case sql_parserParser::USING:
      case sql_parserParser::VALUES:
      case sql_parserParser::VIEW:
      case sql_parserParser::VIEWS:
      case sql_parserParser::WHEN:
      case sql_parserParser::WHERE:
      case sql_parserParser::WINDOW:
      case sql_parserParser::WITH:
      case sql_parserParser::IDENTIFIER:
      case sql_parserParser::BACKQUOTED_IDENTIFIER: {
        _localctx = _tracker.createInstance<sql_parserParser::RealIdentContext>(_localctx);
        enterOuterAlt(_localctx, 2);

        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierContext ------------------------------------------------------------------

sql_parserParser::IdentifierContext::IdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

sql_parserParser::StrictIdentifierContext* sql_parserParser::IdentifierContext::strictIdentifier() {
  return getRuleContext<sql_parserParser::StrictIdentifierContext>(0);
}

sql_parserParser::StrictNonReservedContext* sql_parserParser::IdentifierContext::strictNonReserved() {
  return getRuleContext<sql_parserParser::StrictNonReservedContext>(0);
}


size_t sql_parserParser::IdentifierContext::getRuleIndex() const {
  return sql_parserParser::RuleIdentifier;
}


std::any sql_parserParser::IdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitIdentifier(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::IdentifierContext* sql_parserParser::identifier() {
  IdentifierContext *_localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
  enterRule(_localctx, 124, sql_parserParser::RuleIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(861);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(859);
      strictIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(860);
      strictNonReserved();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StrictIdentifierContext ------------------------------------------------------------------

sql_parserParser::StrictIdentifierContext::StrictIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t sql_parserParser::StrictIdentifierContext::getRuleIndex() const {
  return sql_parserParser::RuleStrictIdentifier;
}

void sql_parserParser::StrictIdentifierContext::copyFrom(StrictIdentifierContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- QuotedIdentifierAlternativeContext ------------------------------------------------------------------

sql_parserParser::QuotedIdentifierContext* sql_parserParser::QuotedIdentifierAlternativeContext::quotedIdentifier() {
  return getRuleContext<sql_parserParser::QuotedIdentifierContext>(0);
}

sql_parserParser::QuotedIdentifierAlternativeContext::QuotedIdentifierAlternativeContext(StrictIdentifierContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::QuotedIdentifierAlternativeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitQuotedIdentifierAlternative(this);
  else
    return visitor->visitChildren(this);
}
//----------------- UnquotedIdentifierContext ------------------------------------------------------------------

tree::TerminalNode* sql_parserParser::UnquotedIdentifierContext::IDENTIFIER() {
  return getToken(sql_parserParser::IDENTIFIER, 0);
}

sql_parserParser::AnsiNonReservedContext* sql_parserParser::UnquotedIdentifierContext::ansiNonReserved() {
  return getRuleContext<sql_parserParser::AnsiNonReservedContext>(0);
}

sql_parserParser::NonReservedContext* sql_parserParser::UnquotedIdentifierContext::nonReserved() {
  return getRuleContext<sql_parserParser::NonReservedContext>(0);
}

sql_parserParser::UnquotedIdentifierContext::UnquotedIdentifierContext(StrictIdentifierContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::UnquotedIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitUnquotedIdentifier(this);
  else
    return visitor->visitChildren(this);
}
sql_parserParser::StrictIdentifierContext* sql_parserParser::strictIdentifier() {
  StrictIdentifierContext *_localctx = _tracker.createInstance<StrictIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 126, sql_parserParser::RuleStrictIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(867);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<sql_parserParser::UnquotedIdentifierContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(863);
      match(sql_parserParser::IDENTIFIER);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<sql_parserParser::QuotedIdentifierAlternativeContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(864);
      quotedIdentifier();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<sql_parserParser::UnquotedIdentifierContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(865);
      ansiNonReserved();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<sql_parserParser::UnquotedIdentifierContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(866);
      nonReserved();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QuotedIdentifierContext ------------------------------------------------------------------

sql_parserParser::QuotedIdentifierContext::QuotedIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* sql_parserParser::QuotedIdentifierContext::BACKQUOTED_IDENTIFIER() {
  return getToken(sql_parserParser::BACKQUOTED_IDENTIFIER, 0);
}


size_t sql_parserParser::QuotedIdentifierContext::getRuleIndex() const {
  return sql_parserParser::RuleQuotedIdentifier;
}


std::any sql_parserParser::QuotedIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitQuotedIdentifier(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::QuotedIdentifierContext* sql_parserParser::quotedIdentifier() {
  QuotedIdentifierContext *_localctx = _tracker.createInstance<QuotedIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 128, sql_parserParser::RuleQuotedIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(869);
    match(sql_parserParser::BACKQUOTED_IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumberContext ------------------------------------------------------------------

sql_parserParser::NumberContext::NumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t sql_parserParser::NumberContext::getRuleIndex() const {
  return sql_parserParser::RuleNumber;
}

void sql_parserParser::NumberContext::copyFrom(NumberContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- BigIntLiteralContext ------------------------------------------------------------------

tree::TerminalNode* sql_parserParser::BigIntLiteralContext::BIGINT_LITERAL() {
  return getToken(sql_parserParser::BIGINT_LITERAL, 0);
}

tree::TerminalNode* sql_parserParser::BigIntLiteralContext::MINUS() {
  return getToken(sql_parserParser::MINUS, 0);
}

sql_parserParser::BigIntLiteralContext::BigIntLiteralContext(NumberContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::BigIntLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitBigIntLiteral(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TinyIntLiteralContext ------------------------------------------------------------------

tree::TerminalNode* sql_parserParser::TinyIntLiteralContext::TINYINT_LITERAL() {
  return getToken(sql_parserParser::TINYINT_LITERAL, 0);
}

tree::TerminalNode* sql_parserParser::TinyIntLiteralContext::MINUS() {
  return getToken(sql_parserParser::MINUS, 0);
}

sql_parserParser::TinyIntLiteralContext::TinyIntLiteralContext(NumberContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::TinyIntLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitTinyIntLiteral(this);
  else
    return visitor->visitChildren(this);
}
//----------------- LegacyDecimalLiteralContext ------------------------------------------------------------------

tree::TerminalNode* sql_parserParser::LegacyDecimalLiteralContext::EXPONENT_VALUE() {
  return getToken(sql_parserParser::EXPONENT_VALUE, 0);
}

tree::TerminalNode* sql_parserParser::LegacyDecimalLiteralContext::DECIMAL_VALUE() {
  return getToken(sql_parserParser::DECIMAL_VALUE, 0);
}

tree::TerminalNode* sql_parserParser::LegacyDecimalLiteralContext::MINUS() {
  return getToken(sql_parserParser::MINUS, 0);
}

sql_parserParser::LegacyDecimalLiteralContext::LegacyDecimalLiteralContext(NumberContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::LegacyDecimalLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitLegacyDecimalLiteral(this);
  else
    return visitor->visitChildren(this);
}
//----------------- BigDecimalLiteralContext ------------------------------------------------------------------

tree::TerminalNode* sql_parserParser::BigDecimalLiteralContext::BIGDECIMAL_LITERAL() {
  return getToken(sql_parserParser::BIGDECIMAL_LITERAL, 0);
}

tree::TerminalNode* sql_parserParser::BigDecimalLiteralContext::MINUS() {
  return getToken(sql_parserParser::MINUS, 0);
}

sql_parserParser::BigDecimalLiteralContext::BigDecimalLiteralContext(NumberContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::BigDecimalLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitBigDecimalLiteral(this);
  else
    return visitor->visitChildren(this);
}
//----------------- DoubleLiteralContext ------------------------------------------------------------------

tree::TerminalNode* sql_parserParser::DoubleLiteralContext::DOUBLE_LITERAL() {
  return getToken(sql_parserParser::DOUBLE_LITERAL, 0);
}

tree::TerminalNode* sql_parserParser::DoubleLiteralContext::MINUS() {
  return getToken(sql_parserParser::MINUS, 0);
}

sql_parserParser::DoubleLiteralContext::DoubleLiteralContext(NumberContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::DoubleLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitDoubleLiteral(this);
  else
    return visitor->visitChildren(this);
}
//----------------- IntegerLiteralContext ------------------------------------------------------------------

tree::TerminalNode* sql_parserParser::IntegerLiteralContext::INTEGER_VALUE() {
  return getToken(sql_parserParser::INTEGER_VALUE, 0);
}

tree::TerminalNode* sql_parserParser::IntegerLiteralContext::MINUS() {
  return getToken(sql_parserParser::MINUS, 0);
}

sql_parserParser::IntegerLiteralContext::IntegerLiteralContext(NumberContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::IntegerLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitIntegerLiteral(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SmallIntLiteralContext ------------------------------------------------------------------

tree::TerminalNode* sql_parserParser::SmallIntLiteralContext::SMALLINT_LITERAL() {
  return getToken(sql_parserParser::SMALLINT_LITERAL, 0);
}

tree::TerminalNode* sql_parserParser::SmallIntLiteralContext::MINUS() {
  return getToken(sql_parserParser::MINUS, 0);
}

sql_parserParser::SmallIntLiteralContext::SmallIntLiteralContext(NumberContext *ctx) { copyFrom(ctx); }


std::any sql_parserParser::SmallIntLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitSmallIntLiteral(this);
  else
    return visitor->visitChildren(this);
}
sql_parserParser::NumberContext* sql_parserParser::number() {
  NumberContext *_localctx = _tracker.createInstance<NumberContext>(_ctx, getState());
  enterRule(_localctx, 130, sql_parserParser::RuleNumber);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(899);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 110, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<sql_parserParser::LegacyDecimalLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(872);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == sql_parserParser::MINUS) {
        setState(871);
        match(sql_parserParser::MINUS);
      }
      setState(874);
      _la = _input->LA(1);
      if (!(_la == sql_parserParser::EXPONENT_VALUE

      || _la == sql_parserParser::DECIMAL_VALUE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<sql_parserParser::IntegerLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(876);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == sql_parserParser::MINUS) {
        setState(875);
        match(sql_parserParser::MINUS);
      }
      setState(878);
      match(sql_parserParser::INTEGER_VALUE);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<sql_parserParser::BigIntLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(880);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == sql_parserParser::MINUS) {
        setState(879);
        match(sql_parserParser::MINUS);
      }
      setState(882);
      match(sql_parserParser::BIGINT_LITERAL);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<sql_parserParser::SmallIntLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(884);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == sql_parserParser::MINUS) {
        setState(883);
        match(sql_parserParser::MINUS);
      }
      setState(886);
      match(sql_parserParser::SMALLINT_LITERAL);
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<sql_parserParser::TinyIntLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(888);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == sql_parserParser::MINUS) {
        setState(887);
        match(sql_parserParser::MINUS);
      }
      setState(890);
      match(sql_parserParser::TINYINT_LITERAL);
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<sql_parserParser::DoubleLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(892);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == sql_parserParser::MINUS) {
        setState(891);
        match(sql_parserParser::MINUS);
      }
      setState(894);
      match(sql_parserParser::DOUBLE_LITERAL);
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<sql_parserParser::BigDecimalLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 7);
      setState(896);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == sql_parserParser::MINUS) {
        setState(895);
        match(sql_parserParser::MINUS);
      }
      setState(898);
      match(sql_parserParser::BIGDECIMAL_LITERAL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterColumnActionContext ------------------------------------------------------------------

sql_parserParser::AlterColumnActionContext::AlterColumnActionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* sql_parserParser::AlterColumnActionContext::TYPE() {
  return getToken(sql_parserParser::TYPE, 0);
}

sql_parserParser::DataTypeContext* sql_parserParser::AlterColumnActionContext::dataType() {
  return getRuleContext<sql_parserParser::DataTypeContext>(0);
}

sql_parserParser::CommentSpecContext* sql_parserParser::AlterColumnActionContext::commentSpec() {
  return getRuleContext<sql_parserParser::CommentSpecContext>(0);
}

sql_parserParser::ColPositionContext* sql_parserParser::AlterColumnActionContext::colPosition() {
  return getRuleContext<sql_parserParser::ColPositionContext>(0);
}

tree::TerminalNode* sql_parserParser::AlterColumnActionContext::NOT() {
  return getToken(sql_parserParser::NOT, 0);
}

tree::TerminalNode* sql_parserParser::AlterColumnActionContext::NULL_() {
  return getToken(sql_parserParser::NULL_, 0);
}

tree::TerminalNode* sql_parserParser::AlterColumnActionContext::SET() {
  return getToken(sql_parserParser::SET, 0);
}

tree::TerminalNode* sql_parserParser::AlterColumnActionContext::DROP() {
  return getToken(sql_parserParser::DROP, 0);
}


size_t sql_parserParser::AlterColumnActionContext::getRuleIndex() const {
  return sql_parserParser::RuleAlterColumnAction;
}


std::any sql_parserParser::AlterColumnActionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitAlterColumnAction(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::AlterColumnActionContext* sql_parserParser::alterColumnAction() {
  AlterColumnActionContext *_localctx = _tracker.createInstance<AlterColumnActionContext>(_ctx, getState());
  enterRule(_localctx, 132, sql_parserParser::RuleAlterColumnAction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(908);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case sql_parserParser::TYPE: {
        enterOuterAlt(_localctx, 1);
        setState(901);
        match(sql_parserParser::TYPE);
        setState(902);
        dataType();
        break;
      }

      case sql_parserParser::COMMENT: {
        enterOuterAlt(_localctx, 2);
        setState(903);
        commentSpec();
        break;
      }

      case sql_parserParser::AFTER:
      case sql_parserParser::FIRST: {
        enterOuterAlt(_localctx, 3);
        setState(904);
        colPosition();
        break;
      }

      case sql_parserParser::DROP:
      case sql_parserParser::SET: {
        enterOuterAlt(_localctx, 4);
        setState(905);
        antlrcpp::downCast<AlterColumnActionContext *>(_localctx)->setOrDrop = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == sql_parserParser::DROP || _la == sql_parserParser::SET)) {
          antlrcpp::downCast<AlterColumnActionContext *>(_localctx)->setOrDrop = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(906);
        match(sql_parserParser::NOT);
        setState(907);
        match(sql_parserParser::NULL_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnsiNonReservedContext ------------------------------------------------------------------

sql_parserParser::AnsiNonReservedContext::AnsiNonReservedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::ADD() {
  return getToken(sql_parserParser::ADD, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::AFTER() {
  return getToken(sql_parserParser::AFTER, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::ALTER() {
  return getToken(sql_parserParser::ALTER, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::ANALYZE() {
  return getToken(sql_parserParser::ANALYZE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::ANTI() {
  return getToken(sql_parserParser::ANTI, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::ARCHIVE() {
  return getToken(sql_parserParser::ARCHIVE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::ARRAY() {
  return getToken(sql_parserParser::ARRAY, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::ASC() {
  return getToken(sql_parserParser::ASC, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::AT() {
  return getToken(sql_parserParser::AT, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::BETWEEN() {
  return getToken(sql_parserParser::BETWEEN, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::BUCKET() {
  return getToken(sql_parserParser::BUCKET, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::BUCKETS() {
  return getToken(sql_parserParser::BUCKETS, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::BY() {
  return getToken(sql_parserParser::BY, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::CACHE() {
  return getToken(sql_parserParser::CACHE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::CASCADE() {
  return getToken(sql_parserParser::CASCADE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::CHANGE() {
  return getToken(sql_parserParser::CHANGE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::CLEAR() {
  return getToken(sql_parserParser::CLEAR, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::CLUSTER() {
  return getToken(sql_parserParser::CLUSTER, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::CLUSTERED() {
  return getToken(sql_parserParser::CLUSTERED, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::CODEGEN() {
  return getToken(sql_parserParser::CODEGEN, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::COLLECTION() {
  return getToken(sql_parserParser::COLLECTION, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::COLUMNS() {
  return getToken(sql_parserParser::COLUMNS, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::COMMENT() {
  return getToken(sql_parserParser::COMMENT, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::COMMIT() {
  return getToken(sql_parserParser::COMMIT, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::COMPACT() {
  return getToken(sql_parserParser::COMPACT, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::COMPACTIONS() {
  return getToken(sql_parserParser::COMPACTIONS, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::COMPUTE() {
  return getToken(sql_parserParser::COMPUTE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::CONCATENATE() {
  return getToken(sql_parserParser::CONCATENATE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::COST() {
  return getToken(sql_parserParser::COST, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::CUBE() {
  return getToken(sql_parserParser::CUBE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::CURRENT() {
  return getToken(sql_parserParser::CURRENT, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::DATA() {
  return getToken(sql_parserParser::DATA, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::DATABASE() {
  return getToken(sql_parserParser::DATABASE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::DATABASES() {
  return getToken(sql_parserParser::DATABASES, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::DBPROPERTIES() {
  return getToken(sql_parserParser::DBPROPERTIES, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::DEFINED() {
  return getToken(sql_parserParser::DEFINED, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::DELETE() {
  return getToken(sql_parserParser::DELETE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::DELIMITED() {
  return getToken(sql_parserParser::DELIMITED, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::DESC() {
  return getToken(sql_parserParser::DESC, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::DESCRIBE() {
  return getToken(sql_parserParser::DESCRIBE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::DFS() {
  return getToken(sql_parserParser::DFS, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::DIRECTORIES() {
  return getToken(sql_parserParser::DIRECTORIES, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::DIRECTORY() {
  return getToken(sql_parserParser::DIRECTORY, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::DISTRIBUTE() {
  return getToken(sql_parserParser::DISTRIBUTE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::DIV() {
  return getToken(sql_parserParser::DIV, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::DROP() {
  return getToken(sql_parserParser::DROP, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::ESCAPED() {
  return getToken(sql_parserParser::ESCAPED, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::EXCHANGE() {
  return getToken(sql_parserParser::EXCHANGE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::EXISTS() {
  return getToken(sql_parserParser::EXISTS, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::EXPLAIN() {
  return getToken(sql_parserParser::EXPLAIN, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::EXPORT() {
  return getToken(sql_parserParser::EXPORT, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::EXTENDED() {
  return getToken(sql_parserParser::EXTENDED, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::EXTERNAL() {
  return getToken(sql_parserParser::EXTERNAL, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::EXTRACT() {
  return getToken(sql_parserParser::EXTRACT, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::FIELDS() {
  return getToken(sql_parserParser::FIELDS, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::FILEFORMAT() {
  return getToken(sql_parserParser::FILEFORMAT, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::FIRST() {
  return getToken(sql_parserParser::FIRST, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::FOLLOWING() {
  return getToken(sql_parserParser::FOLLOWING, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::FORMAT() {
  return getToken(sql_parserParser::FORMAT, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::FORMATTED() {
  return getToken(sql_parserParser::FORMATTED, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::FUNCTION() {
  return getToken(sql_parserParser::FUNCTION, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::FUNCTIONS() {
  return getToken(sql_parserParser::FUNCTIONS, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::GLOBAL() {
  return getToken(sql_parserParser::GLOBAL, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::GROUPING() {
  return getToken(sql_parserParser::GROUPING, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::IF() {
  return getToken(sql_parserParser::IF, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::IGNORE() {
  return getToken(sql_parserParser::IGNORE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::IMPORT() {
  return getToken(sql_parserParser::IMPORT, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::INDEX() {
  return getToken(sql_parserParser::INDEX, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::INDEXES() {
  return getToken(sql_parserParser::INDEXES, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::INPATH() {
  return getToken(sql_parserParser::INPATH, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::INPUTFORMAT() {
  return getToken(sql_parserParser::INPUTFORMAT, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::INSERT() {
  return getToken(sql_parserParser::INSERT, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::INTERVAL() {
  return getToken(sql_parserParser::INTERVAL, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::ITEMS() {
  return getToken(sql_parserParser::ITEMS, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::KEYS() {
  return getToken(sql_parserParser::KEYS, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::LAST() {
  return getToken(sql_parserParser::LAST, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::LATERAL() {
  return getToken(sql_parserParser::LATERAL, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::LAZY() {
  return getToken(sql_parserParser::LAZY, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::LIKE() {
  return getToken(sql_parserParser::LIKE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::LIMIT() {
  return getToken(sql_parserParser::LIMIT, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::LINES() {
  return getToken(sql_parserParser::LINES, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::LIST() {
  return getToken(sql_parserParser::LIST, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::LOAD() {
  return getToken(sql_parserParser::LOAD, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::LOCAL() {
  return getToken(sql_parserParser::LOCAL, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::LOCATION() {
  return getToken(sql_parserParser::LOCATION, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::LOCK() {
  return getToken(sql_parserParser::LOCK, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::LOCKS() {
  return getToken(sql_parserParser::LOCKS, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::LOGICAL() {
  return getToken(sql_parserParser::LOGICAL, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::MACRO() {
  return getToken(sql_parserParser::MACRO, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::MAP() {
  return getToken(sql_parserParser::MAP, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::MATCHED() {
  return getToken(sql_parserParser::MATCHED, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::MERGE() {
  return getToken(sql_parserParser::MERGE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::MSCK() {
  return getToken(sql_parserParser::MSCK, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::NAMESPACE() {
  return getToken(sql_parserParser::NAMESPACE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::NAMESPACES() {
  return getToken(sql_parserParser::NAMESPACES, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::NO() {
  return getToken(sql_parserParser::NO, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::NULLS() {
  return getToken(sql_parserParser::NULLS, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::OF() {
  return getToken(sql_parserParser::OF, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::OPTION() {
  return getToken(sql_parserParser::OPTION, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::OPTIONS() {
  return getToken(sql_parserParser::OPTIONS, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::OUT() {
  return getToken(sql_parserParser::OUT, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::OUTPUTFORMAT() {
  return getToken(sql_parserParser::OUTPUTFORMAT, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::OVER() {
  return getToken(sql_parserParser::OVER, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::OVERLAY() {
  return getToken(sql_parserParser::OVERLAY, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::OVERWRITE() {
  return getToken(sql_parserParser::OVERWRITE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::PARTITION() {
  return getToken(sql_parserParser::PARTITION, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::PARTITIONED() {
  return getToken(sql_parserParser::PARTITIONED, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::PARTITIONS() {
  return getToken(sql_parserParser::PARTITIONS, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::PERCENTLIT() {
  return getToken(sql_parserParser::PERCENTLIT, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::PIVOT() {
  return getToken(sql_parserParser::PIVOT, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::PLACING() {
  return getToken(sql_parserParser::PLACING, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::POSITION() {
  return getToken(sql_parserParser::POSITION, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::PRECEDING() {
  return getToken(sql_parserParser::PRECEDING, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::PRINCIPALS() {
  return getToken(sql_parserParser::PRINCIPALS, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::PROPERTIES() {
  return getToken(sql_parserParser::PROPERTIES, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::PURGE() {
  return getToken(sql_parserParser::PURGE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::QUERY() {
  return getToken(sql_parserParser::QUERY, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::RANGE() {
  return getToken(sql_parserParser::RANGE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::RECORDREADER() {
  return getToken(sql_parserParser::RECORDREADER, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::RECORDWRITER() {
  return getToken(sql_parserParser::RECORDWRITER, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::RECOVER() {
  return getToken(sql_parserParser::RECOVER, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::REDUCE() {
  return getToken(sql_parserParser::REDUCE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::REFRESH() {
  return getToken(sql_parserParser::REFRESH, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::RENAME() {
  return getToken(sql_parserParser::RENAME, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::REPAIR() {
  return getToken(sql_parserParser::REPAIR, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::REPLACE() {
  return getToken(sql_parserParser::REPLACE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::RESET() {
  return getToken(sql_parserParser::RESET, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::RESTRICT() {
  return getToken(sql_parserParser::RESTRICT, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::REVOKE() {
  return getToken(sql_parserParser::REVOKE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::RLIKE() {
  return getToken(sql_parserParser::RLIKE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::ROLE() {
  return getToken(sql_parserParser::ROLE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::ROLES() {
  return getToken(sql_parserParser::ROLES, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::ROLLBACK() {
  return getToken(sql_parserParser::ROLLBACK, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::ROLLUP() {
  return getToken(sql_parserParser::ROLLUP, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::ROW() {
  return getToken(sql_parserParser::ROW, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::ROWS() {
  return getToken(sql_parserParser::ROWS, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::SCHEMA() {
  return getToken(sql_parserParser::SCHEMA, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::SEMI() {
  return getToken(sql_parserParser::SEMI, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::SEPARATED() {
  return getToken(sql_parserParser::SEPARATED, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::SERDE() {
  return getToken(sql_parserParser::SERDE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::SERDEPROPERTIES() {
  return getToken(sql_parserParser::SERDEPROPERTIES, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::SET() {
  return getToken(sql_parserParser::SET, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::SETMINUS() {
  return getToken(sql_parserParser::SETMINUS, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::SETS() {
  return getToken(sql_parserParser::SETS, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::SHOW() {
  return getToken(sql_parserParser::SHOW, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::SKEWED() {
  return getToken(sql_parserParser::SKEWED, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::SORT() {
  return getToken(sql_parserParser::SORT, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::SORTED() {
  return getToken(sql_parserParser::SORTED, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::START() {
  return getToken(sql_parserParser::START, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::STATISTICS() {
  return getToken(sql_parserParser::STATISTICS, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::STORED() {
  return getToken(sql_parserParser::STORED, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::STRATIFY() {
  return getToken(sql_parserParser::STRATIFY, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::STRUCT() {
  return getToken(sql_parserParser::STRUCT, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::SUBSTR() {
  return getToken(sql_parserParser::SUBSTR, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::SUBSTRING() {
  return getToken(sql_parserParser::SUBSTRING, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::TABLES() {
  return getToken(sql_parserParser::TABLES, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::TABLESAMPLE() {
  return getToken(sql_parserParser::TABLESAMPLE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::TBLPROPERTIES() {
  return getToken(sql_parserParser::TBLPROPERTIES, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::TEMPORARY() {
  return getToken(sql_parserParser::TEMPORARY, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::TERMINATED() {
  return getToken(sql_parserParser::TERMINATED, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::TOUCH() {
  return getToken(sql_parserParser::TOUCH, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::TRANSACTION() {
  return getToken(sql_parserParser::TRANSACTION, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::TRANSACTIONS() {
  return getToken(sql_parserParser::TRANSACTIONS, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::TRANSFORM() {
  return getToken(sql_parserParser::TRANSFORM, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::TRIM() {
  return getToken(sql_parserParser::TRIM, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::TRUE() {
  return getToken(sql_parserParser::TRUE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::TRUNCATE() {
  return getToken(sql_parserParser::TRUNCATE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::TYPE() {
  return getToken(sql_parserParser::TYPE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::UNARCHIVE() {
  return getToken(sql_parserParser::UNARCHIVE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::UNBOUNDED() {
  return getToken(sql_parserParser::UNBOUNDED, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::UNCACHE() {
  return getToken(sql_parserParser::UNCACHE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::UNLOCK() {
  return getToken(sql_parserParser::UNLOCK, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::UNSET() {
  return getToken(sql_parserParser::UNSET, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::UPDATE() {
  return getToken(sql_parserParser::UPDATE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::USE() {
  return getToken(sql_parserParser::USE, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::VALUES() {
  return getToken(sql_parserParser::VALUES, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::VIEW() {
  return getToken(sql_parserParser::VIEW, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::VIEWS() {
  return getToken(sql_parserParser::VIEWS, 0);
}

tree::TerminalNode* sql_parserParser::AnsiNonReservedContext::WINDOW() {
  return getToken(sql_parserParser::WINDOW, 0);
}


size_t sql_parserParser::AnsiNonReservedContext::getRuleIndex() const {
  return sql_parserParser::RuleAnsiNonReserved;
}


std::any sql_parserParser::AnsiNonReservedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitAnsiNonReserved(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::AnsiNonReservedContext* sql_parserParser::ansiNonReserved() {
  AnsiNonReservedContext *_localctx = _tracker.createInstance<AnsiNonReservedContext>(_ctx, getState());
  enterRule(_localctx, 134, sql_parserParser::RuleAnsiNonReserved);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(910);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -273876538561743360) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 4408704324763362239) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & -4629718019216113665) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & 5654550617893105535) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StrictNonReservedContext ------------------------------------------------------------------

sql_parserParser::StrictNonReservedContext::StrictNonReservedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* sql_parserParser::StrictNonReservedContext::ANTI() {
  return getToken(sql_parserParser::ANTI, 0);
}

tree::TerminalNode* sql_parserParser::StrictNonReservedContext::CROSS() {
  return getToken(sql_parserParser::CROSS, 0);
}

tree::TerminalNode* sql_parserParser::StrictNonReservedContext::EXCEPT() {
  return getToken(sql_parserParser::EXCEPT, 0);
}

tree::TerminalNode* sql_parserParser::StrictNonReservedContext::FULL() {
  return getToken(sql_parserParser::FULL, 0);
}

tree::TerminalNode* sql_parserParser::StrictNonReservedContext::INNER() {
  return getToken(sql_parserParser::INNER, 0);
}

tree::TerminalNode* sql_parserParser::StrictNonReservedContext::INTERSECT() {
  return getToken(sql_parserParser::INTERSECT, 0);
}

tree::TerminalNode* sql_parserParser::StrictNonReservedContext::JOIN() {
  return getToken(sql_parserParser::JOIN, 0);
}

tree::TerminalNode* sql_parserParser::StrictNonReservedContext::LEFT() {
  return getToken(sql_parserParser::LEFT, 0);
}

tree::TerminalNode* sql_parserParser::StrictNonReservedContext::NATURAL() {
  return getToken(sql_parserParser::NATURAL, 0);
}

tree::TerminalNode* sql_parserParser::StrictNonReservedContext::ON() {
  return getToken(sql_parserParser::ON, 0);
}

tree::TerminalNode* sql_parserParser::StrictNonReservedContext::RIGHT() {
  return getToken(sql_parserParser::RIGHT, 0);
}

tree::TerminalNode* sql_parserParser::StrictNonReservedContext::SEMI() {
  return getToken(sql_parserParser::SEMI, 0);
}

tree::TerminalNode* sql_parserParser::StrictNonReservedContext::SETMINUS() {
  return getToken(sql_parserParser::SETMINUS, 0);
}

tree::TerminalNode* sql_parserParser::StrictNonReservedContext::UNION() {
  return getToken(sql_parserParser::UNION, 0);
}

tree::TerminalNode* sql_parserParser::StrictNonReservedContext::USING() {
  return getToken(sql_parserParser::USING, 0);
}


size_t sql_parserParser::StrictNonReservedContext::getRuleIndex() const {
  return sql_parserParser::RuleStrictNonReserved;
}


std::any sql_parserParser::StrictNonReservedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitStrictNonReserved(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::StrictNonReservedContext* sql_parserParser::strictNonReserved() {
  StrictNonReservedContext *_localctx = _tracker.createInstance<StrictNonReservedContext>(_ctx, getState());
  enterRule(_localctx, 136, sql_parserParser::RuleStrictNonReserved);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(912);
    _la = _input->LA(1);
    if (!(((((_la - 15) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 15)) & -9223371968135299071) != 0) || ((((_la - 98) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 98)) & 9147937288634369) != 0) || ((((_la - 190) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 190)) & 289356276058620929) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NonReservedContext ------------------------------------------------------------------

sql_parserParser::NonReservedContext::NonReservedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* sql_parserParser::NonReservedContext::ADD() {
  return getToken(sql_parserParser::ADD, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::AFTER() {
  return getToken(sql_parserParser::AFTER, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::ALL() {
  return getToken(sql_parserParser::ALL, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::ALTER() {
  return getToken(sql_parserParser::ALTER, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::ANALYZE() {
  return getToken(sql_parserParser::ANALYZE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::AND() {
  return getToken(sql_parserParser::AND, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::ANY() {
  return getToken(sql_parserParser::ANY, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::ARCHIVE() {
  return getToken(sql_parserParser::ARCHIVE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::ARRAY() {
  return getToken(sql_parserParser::ARRAY, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::AS() {
  return getToken(sql_parserParser::AS, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::ASC() {
  return getToken(sql_parserParser::ASC, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::AT() {
  return getToken(sql_parserParser::AT, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::AUTHORIZATION() {
  return getToken(sql_parserParser::AUTHORIZATION, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::BETWEEN() {
  return getToken(sql_parserParser::BETWEEN, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::BOTH() {
  return getToken(sql_parserParser::BOTH, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::BUCKET() {
  return getToken(sql_parserParser::BUCKET, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::BUCKETS() {
  return getToken(sql_parserParser::BUCKETS, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::BY() {
  return getToken(sql_parserParser::BY, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::CACHE() {
  return getToken(sql_parserParser::CACHE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::CASCADE() {
  return getToken(sql_parserParser::CASCADE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::CASE() {
  return getToken(sql_parserParser::CASE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::CAST() {
  return getToken(sql_parserParser::CAST, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::CHANGE() {
  return getToken(sql_parserParser::CHANGE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::CHECK() {
  return getToken(sql_parserParser::CHECK, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::CLEAR() {
  return getToken(sql_parserParser::CLEAR, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::CLUSTER() {
  return getToken(sql_parserParser::CLUSTER, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::CLUSTERED() {
  return getToken(sql_parserParser::CLUSTERED, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::CODEGEN() {
  return getToken(sql_parserParser::CODEGEN, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::COLLATE() {
  return getToken(sql_parserParser::COLLATE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::COLLECTION() {
  return getToken(sql_parserParser::COLLECTION, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::COLUMN() {
  return getToken(sql_parserParser::COLUMN, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::COLUMNS() {
  return getToken(sql_parserParser::COLUMNS, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::COMMENT() {
  return getToken(sql_parserParser::COMMENT, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::COMMIT() {
  return getToken(sql_parserParser::COMMIT, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::COMPACT() {
  return getToken(sql_parserParser::COMPACT, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::COMPACTIONS() {
  return getToken(sql_parserParser::COMPACTIONS, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::COMPUTE() {
  return getToken(sql_parserParser::COMPUTE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::CONCATENATE() {
  return getToken(sql_parserParser::CONCATENATE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::CONSTRAINT() {
  return getToken(sql_parserParser::CONSTRAINT, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::COST() {
  return getToken(sql_parserParser::COST, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::CREATE() {
  return getToken(sql_parserParser::CREATE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::CUBE() {
  return getToken(sql_parserParser::CUBE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::CURRENT() {
  return getToken(sql_parserParser::CURRENT, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::CURRENT_DATE() {
  return getToken(sql_parserParser::CURRENT_DATE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::CURRENT_TIME() {
  return getToken(sql_parserParser::CURRENT_TIME, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::CURRENT_TIMESTAMP() {
  return getToken(sql_parserParser::CURRENT_TIMESTAMP, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::CURRENT_USER() {
  return getToken(sql_parserParser::CURRENT_USER, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::DATA() {
  return getToken(sql_parserParser::DATA, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::DATABASE() {
  return getToken(sql_parserParser::DATABASE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::DATABASES() {
  return getToken(sql_parserParser::DATABASES, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::DBPROPERTIES() {
  return getToken(sql_parserParser::DBPROPERTIES, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::DEFINED() {
  return getToken(sql_parserParser::DEFINED, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::DELETE() {
  return getToken(sql_parserParser::DELETE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::DELIMITED() {
  return getToken(sql_parserParser::DELIMITED, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::DESC() {
  return getToken(sql_parserParser::DESC, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::DESCRIBE() {
  return getToken(sql_parserParser::DESCRIBE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::DFS() {
  return getToken(sql_parserParser::DFS, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::DIRECTORIES() {
  return getToken(sql_parserParser::DIRECTORIES, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::DIRECTORY() {
  return getToken(sql_parserParser::DIRECTORY, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::DISTINCT() {
  return getToken(sql_parserParser::DISTINCT, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::DISTRIBUTE() {
  return getToken(sql_parserParser::DISTRIBUTE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::DIV() {
  return getToken(sql_parserParser::DIV, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::DROP() {
  return getToken(sql_parserParser::DROP, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::ELSE() {
  return getToken(sql_parserParser::ELSE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::END() {
  return getToken(sql_parserParser::END, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::ESCAPE() {
  return getToken(sql_parserParser::ESCAPE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::ESCAPED() {
  return getToken(sql_parserParser::ESCAPED, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::EXCHANGE() {
  return getToken(sql_parserParser::EXCHANGE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::EXISTS() {
  return getToken(sql_parserParser::EXISTS, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::EXPLAIN() {
  return getToken(sql_parserParser::EXPLAIN, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::EXPORT() {
  return getToken(sql_parserParser::EXPORT, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::EXTENDED() {
  return getToken(sql_parserParser::EXTENDED, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::EXTERNAL() {
  return getToken(sql_parserParser::EXTERNAL, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::EXTRACT() {
  return getToken(sql_parserParser::EXTRACT, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::FALSE() {
  return getToken(sql_parserParser::FALSE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::FETCH() {
  return getToken(sql_parserParser::FETCH, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::FILTER() {
  return getToken(sql_parserParser::FILTER, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::FIELDS() {
  return getToken(sql_parserParser::FIELDS, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::FILEFORMAT() {
  return getToken(sql_parserParser::FILEFORMAT, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::FIRST() {
  return getToken(sql_parserParser::FIRST, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::FOLLOWING() {
  return getToken(sql_parserParser::FOLLOWING, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::FOR() {
  return getToken(sql_parserParser::FOR, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::FOREIGN() {
  return getToken(sql_parserParser::FOREIGN, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::FORMAT() {
  return getToken(sql_parserParser::FORMAT, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::FORMATTED() {
  return getToken(sql_parserParser::FORMATTED, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::FROM() {
  return getToken(sql_parserParser::FROM, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::FUNCTION() {
  return getToken(sql_parserParser::FUNCTION, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::FUNCTIONS() {
  return getToken(sql_parserParser::FUNCTIONS, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::GLOBAL() {
  return getToken(sql_parserParser::GLOBAL, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::GRANT() {
  return getToken(sql_parserParser::GRANT, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::GROUP() {
  return getToken(sql_parserParser::GROUP, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::GROUPING() {
  return getToken(sql_parserParser::GROUPING, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::HAVING() {
  return getToken(sql_parserParser::HAVING, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::IF() {
  return getToken(sql_parserParser::IF, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::IGNORE() {
  return getToken(sql_parserParser::IGNORE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::IMPORT() {
  return getToken(sql_parserParser::IMPORT, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::IN() {
  return getToken(sql_parserParser::IN, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::INDEX() {
  return getToken(sql_parserParser::INDEX, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::INDEXES() {
  return getToken(sql_parserParser::INDEXES, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::INPATH() {
  return getToken(sql_parserParser::INPATH, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::INPUTFORMAT() {
  return getToken(sql_parserParser::INPUTFORMAT, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::INSERT() {
  return getToken(sql_parserParser::INSERT, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::INTERVAL() {
  return getToken(sql_parserParser::INTERVAL, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::INTO() {
  return getToken(sql_parserParser::INTO, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::IS() {
  return getToken(sql_parserParser::IS, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::ITEMS() {
  return getToken(sql_parserParser::ITEMS, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::KEYS() {
  return getToken(sql_parserParser::KEYS, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::LAST() {
  return getToken(sql_parserParser::LAST, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::LATERAL() {
  return getToken(sql_parserParser::LATERAL, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::LAZY() {
  return getToken(sql_parserParser::LAZY, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::LEADING() {
  return getToken(sql_parserParser::LEADING, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::LIKE() {
  return getToken(sql_parserParser::LIKE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::LIMIT() {
  return getToken(sql_parserParser::LIMIT, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::LINES() {
  return getToken(sql_parserParser::LINES, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::LIST() {
  return getToken(sql_parserParser::LIST, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::LOAD() {
  return getToken(sql_parserParser::LOAD, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::LOCAL() {
  return getToken(sql_parserParser::LOCAL, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::LOCATION() {
  return getToken(sql_parserParser::LOCATION, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::LOCK() {
  return getToken(sql_parserParser::LOCK, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::LOCKS() {
  return getToken(sql_parserParser::LOCKS, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::LOGICAL() {
  return getToken(sql_parserParser::LOGICAL, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::MACRO() {
  return getToken(sql_parserParser::MACRO, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::MAP() {
  return getToken(sql_parserParser::MAP, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::MATCHED() {
  return getToken(sql_parserParser::MATCHED, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::MERGE() {
  return getToken(sql_parserParser::MERGE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::MSCK() {
  return getToken(sql_parserParser::MSCK, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::NAMESPACE() {
  return getToken(sql_parserParser::NAMESPACE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::NAMESPACES() {
  return getToken(sql_parserParser::NAMESPACES, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::NO() {
  return getToken(sql_parserParser::NO, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::NOT() {
  return getToken(sql_parserParser::NOT, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::NULL_() {
  return getToken(sql_parserParser::NULL_, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::NULLS() {
  return getToken(sql_parserParser::NULLS, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::OF() {
  return getToken(sql_parserParser::OF, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::ONLY() {
  return getToken(sql_parserParser::ONLY, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::OPTION() {
  return getToken(sql_parserParser::OPTION, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::OPTIONS() {
  return getToken(sql_parserParser::OPTIONS, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::OR() {
  return getToken(sql_parserParser::OR, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::ORDER() {
  return getToken(sql_parserParser::ORDER, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::OUT() {
  return getToken(sql_parserParser::OUT, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::OUTER() {
  return getToken(sql_parserParser::OUTER, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::OUTPUTFORMAT() {
  return getToken(sql_parserParser::OUTPUTFORMAT, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::OVER() {
  return getToken(sql_parserParser::OVER, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::OVERLAPS() {
  return getToken(sql_parserParser::OVERLAPS, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::OVERLAY() {
  return getToken(sql_parserParser::OVERLAY, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::OVERWRITE() {
  return getToken(sql_parserParser::OVERWRITE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::PARTITION() {
  return getToken(sql_parserParser::PARTITION, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::PARTITIONED() {
  return getToken(sql_parserParser::PARTITIONED, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::PARTITIONS() {
  return getToken(sql_parserParser::PARTITIONS, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::PERCENTLIT() {
  return getToken(sql_parserParser::PERCENTLIT, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::PIVOT() {
  return getToken(sql_parserParser::PIVOT, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::PLACING() {
  return getToken(sql_parserParser::PLACING, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::POSITION() {
  return getToken(sql_parserParser::POSITION, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::PRECEDING() {
  return getToken(sql_parserParser::PRECEDING, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::PRIMARY() {
  return getToken(sql_parserParser::PRIMARY, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::PRINCIPALS() {
  return getToken(sql_parserParser::PRINCIPALS, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::PROPERTIES() {
  return getToken(sql_parserParser::PROPERTIES, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::PURGE() {
  return getToken(sql_parserParser::PURGE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::QUERY() {
  return getToken(sql_parserParser::QUERY, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::RANGE() {
  return getToken(sql_parserParser::RANGE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::RECORDREADER() {
  return getToken(sql_parserParser::RECORDREADER, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::RECORDWRITER() {
  return getToken(sql_parserParser::RECORDWRITER, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::RECOVER() {
  return getToken(sql_parserParser::RECOVER, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::REDUCE() {
  return getToken(sql_parserParser::REDUCE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::REFERENCES() {
  return getToken(sql_parserParser::REFERENCES, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::REFRESH() {
  return getToken(sql_parserParser::REFRESH, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::RENAME() {
  return getToken(sql_parserParser::RENAME, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::REPAIR() {
  return getToken(sql_parserParser::REPAIR, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::REPLACE() {
  return getToken(sql_parserParser::REPLACE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::RESET() {
  return getToken(sql_parserParser::RESET, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::RESTRICT() {
  return getToken(sql_parserParser::RESTRICT, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::REVOKE() {
  return getToken(sql_parserParser::REVOKE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::RLIKE() {
  return getToken(sql_parserParser::RLIKE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::ROLE() {
  return getToken(sql_parserParser::ROLE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::ROLES() {
  return getToken(sql_parserParser::ROLES, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::ROLLBACK() {
  return getToken(sql_parserParser::ROLLBACK, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::ROLLUP() {
  return getToken(sql_parserParser::ROLLUP, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::ROW() {
  return getToken(sql_parserParser::ROW, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::ROWS() {
  return getToken(sql_parserParser::ROWS, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::SCHEMA() {
  return getToken(sql_parserParser::SCHEMA, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::SELECT() {
  return getToken(sql_parserParser::SELECT, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::SEPARATED() {
  return getToken(sql_parserParser::SEPARATED, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::SERDE() {
  return getToken(sql_parserParser::SERDE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::SERDEPROPERTIES() {
  return getToken(sql_parserParser::SERDEPROPERTIES, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::SESSION_USER() {
  return getToken(sql_parserParser::SESSION_USER, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::SET() {
  return getToken(sql_parserParser::SET, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::SETS() {
  return getToken(sql_parserParser::SETS, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::SHOW() {
  return getToken(sql_parserParser::SHOW, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::SKEWED() {
  return getToken(sql_parserParser::SKEWED, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::SOME() {
  return getToken(sql_parserParser::SOME, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::SORT() {
  return getToken(sql_parserParser::SORT, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::SORTED() {
  return getToken(sql_parserParser::SORTED, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::START() {
  return getToken(sql_parserParser::START, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::STATISTICS() {
  return getToken(sql_parserParser::STATISTICS, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::STORED() {
  return getToken(sql_parserParser::STORED, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::STRATIFY() {
  return getToken(sql_parserParser::STRATIFY, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::STRUCT() {
  return getToken(sql_parserParser::STRUCT, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::SUBSTR() {
  return getToken(sql_parserParser::SUBSTR, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::SUBSTRING() {
  return getToken(sql_parserParser::SUBSTRING, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::TABLE() {
  return getToken(sql_parserParser::TABLE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::TABLES() {
  return getToken(sql_parserParser::TABLES, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::TABLESAMPLE() {
  return getToken(sql_parserParser::TABLESAMPLE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::TBLPROPERTIES() {
  return getToken(sql_parserParser::TBLPROPERTIES, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::TEMPORARY() {
  return getToken(sql_parserParser::TEMPORARY, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::TERMINATED() {
  return getToken(sql_parserParser::TERMINATED, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::THEN() {
  return getToken(sql_parserParser::THEN, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::TO() {
  return getToken(sql_parserParser::TO, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::TOUCH() {
  return getToken(sql_parserParser::TOUCH, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::TRAILING() {
  return getToken(sql_parserParser::TRAILING, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::TRANSACTION() {
  return getToken(sql_parserParser::TRANSACTION, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::TRANSACTIONS() {
  return getToken(sql_parserParser::TRANSACTIONS, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::TRANSFORM() {
  return getToken(sql_parserParser::TRANSFORM, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::TRIM() {
  return getToken(sql_parserParser::TRIM, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::TRUE() {
  return getToken(sql_parserParser::TRUE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::TRUNCATE() {
  return getToken(sql_parserParser::TRUNCATE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::TYPE() {
  return getToken(sql_parserParser::TYPE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::UNARCHIVE() {
  return getToken(sql_parserParser::UNARCHIVE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::UNBOUNDED() {
  return getToken(sql_parserParser::UNBOUNDED, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::UNCACHE() {
  return getToken(sql_parserParser::UNCACHE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::UNIQUE() {
  return getToken(sql_parserParser::UNIQUE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::UNKNOWN() {
  return getToken(sql_parserParser::UNKNOWN, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::UNLOCK() {
  return getToken(sql_parserParser::UNLOCK, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::UNSET() {
  return getToken(sql_parserParser::UNSET, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::UPDATE() {
  return getToken(sql_parserParser::UPDATE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::USE() {
  return getToken(sql_parserParser::USE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::USER() {
  return getToken(sql_parserParser::USER, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::VALUES() {
  return getToken(sql_parserParser::VALUES, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::VIEW() {
  return getToken(sql_parserParser::VIEW, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::VIEWS() {
  return getToken(sql_parserParser::VIEWS, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::WHEN() {
  return getToken(sql_parserParser::WHEN, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::WHERE() {
  return getToken(sql_parserParser::WHERE, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::WINDOW() {
  return getToken(sql_parserParser::WINDOW, 0);
}

tree::TerminalNode* sql_parserParser::NonReservedContext::WITH() {
  return getToken(sql_parserParser::WITH, 0);
}


size_t sql_parserParser::NonReservedContext::getRuleIndex() const {
  return sql_parserParser::RuleNonReserved;
}


std::any sql_parserParser::NonReservedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<sql_parserVisitor*>(visitor))
    return parserVisitor->visitNonReserved(this);
  else
    return visitor->visitChildren(this);
}

sql_parserParser::NonReservedContext* sql_parserParser::nonReserved() {
  NonReservedContext *_localctx = _tracker.createInstance<NonReservedContext>(_ctx, getState());
  enterRule(_localctx, 138, sql_parserParser::RuleNonReserved);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(914);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -2251799813718528) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 9074471756994953215) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & -4611686018435907585) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & -72339069014655233) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool sql_parserParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 28: return booleanExpressionSempred(antlrcpp::downCast<BooleanExpressionContext *>(context), predicateIndex);
    case 30: return valueExpressionSempred(antlrcpp::downCast<ValueExpressionContext *>(context), predicateIndex);
    case 31: return primaryExpressionSempred(antlrcpp::downCast<PrimaryExpressionContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool sql_parserParser::booleanExpressionSempred(BooleanExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 2);
    case 1: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool sql_parserParser::valueExpressionSempred(ValueExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 2: return precpred(_ctx, 6);
    case 3: return precpred(_ctx, 5);
    case 4: return precpred(_ctx, 4);
    case 5: return precpred(_ctx, 3);
    case 6: return precpred(_ctx, 2);
    case 7: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool sql_parserParser::primaryExpressionSempred(PrimaryExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 8: return precpred(_ctx, 4);
    case 9: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

void sql_parserParser::initialize() {
  ::antlr4::internal::call_once(sql_parserParserOnceFlag, sql_parserParserInitialize);
}
